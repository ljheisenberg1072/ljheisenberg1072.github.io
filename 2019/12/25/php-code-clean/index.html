<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>PHP 代码简洁之道 | LJHeisenberg&#39; Blog</title>
  <meta name="keywords" content=" Clean ">
  <meta name="description" content="PHP 代码简洁之道 | LJHeisenberg&#39; Blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="个人简介ljheisenberg， 目前从事 PHP 及网站运维相关工作 终生学习，每日精进 最近在公司使用 Laravel 框架重构公司的项目 联系方式 QQ：2638484046 Email：ljheisenberg@163.com">
<meta name="keywords" content="ljheisenberg">
<meta property="og:type" content="website">
<meta property="og:title" content="关于自己">
<meta property="og:url" content="https:&#x2F;&#x2F;ljheisenberg1072.github.io&#x2F;about&#x2F;index.html">
<meta property="og:site_name" content="LJHeisenberg&#39; Blog">
<meta property="og:description" content="个人简介ljheisenberg， 目前从事 PHP 及网站运维相关工作 终生学习，每日精进 最近在公司使用 Laravel 框架重构公司的项目 联系方式 QQ：2638484046 Email：ljheisenberg@163.com">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-11-20T05:17:26.555Z">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.0.1" rel="stylesheet">

<link href="/css/hl_theme/sublime.css?v=1.0.1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js?v=1.0.1" ></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.0.1" ></script>

<link rel="alternate" href="/atom.xml" title="LJHeisenberg' Blog" type="application/atom+xml">
</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="true">
  <input class="theme_blog_path" value="">
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>LJHeisenberg</span>
</div>

<div class="icon">
    
        
        <a title="rss" href="/atom.xml" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-rss"></use>
                </svg>
            
        </a>
        
    
        
        <a title="github" href="https://github.com/ljheisenberg1072" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
        <a title="email" href="mailto:ljheisenberg@163.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"></use>
                </svg>
            
        </a>
        
    
        
        <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=2638484046&site=qq&menu=yes" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-qq"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
</div>




<ul>
    <li><div class="all active">全部文章<small>(4)</small></div></li>
    
        
            
            <li><div data-rel="Laravel">Laravel<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="Comment">Comment<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="Member">Member<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="PHP">PHP<small>(1)</small></div>
                
            </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a class="about  site_url"  href="/about">关于</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="4">
<input type="hidden" id="yelog_site_word_count" value="13.3k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode==13){return false;}">
        <input class="search" type="text" placeholder="Search..." autocomplete="off"id="local-search-input" >
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none" />
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a class="color3">部署</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">评论</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">会员</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">Clean</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <nav id="title-list-nav">
        
        <a  class="Laravel "
           href="/2019/11/20/deploy-laravel-project-byhands/"
           data-tag="部署"
           data-author="" >
            <span class="post-title" title="手动部署 Laravel 应用">手动部署 Laravel 应用</span>
            <span class="post-date" title="2019-11-20 12:30:44">2019/11/20</span>
        </a>
        
        <a  class="Comment "
           href="/2021/02/27/laravel-nested-comment-realization/"
           data-tag="评论"
           data-author="" >
            <span class="post-title" title="Laravel嵌套评论的实现">Laravel嵌套评论的实现</span>
            <span class="post-date" title="2021-02-27 20:30:44">2021/02/27</span>
        </a>
        
        <a  class="Member "
           href="/2021/02/28/design-of-membership-points-system/"
           data-tag="会员"
           data-author="" >
            <span class="post-title" title="会员积分体系设计">会员积分体系设计</span>
            <span class="post-date" title="2021-02-28 00:54:44">2021/02/28</span>
        </a>
        
        <a  class="PHP "
           href="/2019/12/25/php-code-clean/"
           data-tag="Clean"
           data-author="" >
            <span class="post-title" title="PHP 代码简洁之道">PHP 代码简洁之道</span>
            <span class="post-date" title="2019-12-25 10:40:44">2019/12/25</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-php-code-clean" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">PHP 代码简洁之道</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            
                <a  data-rel="PHP">PHP</a>
            
        </span>
        
        
        <span class="tag">
            
            <a class="color1">Clean</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title='更新时间: 2019-12-25 10:45:56'>2019-12-25 10:40</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:7.2k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                评论:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#PHP-代码简洁之道"><span class="toc-text">PHP 代码简洁之道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#介绍"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量"><span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用有意义的且可读的变量名"><span class="toc-text">使用有意义的且可读的变量名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对同类型的变量使用相同的词汇"><span class="toc-text">对同类型的变量使用相同的词汇</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用可搜索的名称（第一部分）"><span class="toc-text">使用可搜索的名称（第一部分）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用可搜索的名称（第二部分）"><span class="toc-text">使用可搜索的名称（第二部分）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用解释性变量"><span class="toc-text">使用解释性变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#避免嵌套太深和提前返回-第一部分"><span class="toc-text">避免嵌套太深和提前返回 (第一部分)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#避免嵌套太深和提前返回-第二部分"><span class="toc-text">避免嵌套太深和提前返回 (第二部分)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#避免心理映射"><span class="toc-text">避免心理映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不要增加不需要的上下文"><span class="toc-text">不要增加不需要的上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用默认参数而不是使用短路运算或者是条件判断"><span class="toc-text">使用默认参数而不是使用短路运算或者是条件判断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对比"><span class="toc-text">对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-相等运算符"><span class="toc-text">使用 相等运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数"><span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数参数（2-个或更少）"><span class="toc-text">函数参数（2 个或更少）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数应该只做一件事情"><span class="toc-text">函数应该只做一件事情</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数的名称要说清楚它做什么"><span class="toc-text">函数的名称要说清楚它做什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数只能是一个抽象级别"><span class="toc-text">函数只能是一个抽象级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不要用标示作为函数的参数"><span class="toc-text">不要用标示作为函数的参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#避免副作用"><span class="toc-text">避免副作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不要定义全局函数"><span class="toc-text">不要定义全局函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不要使用单例模式"><span class="toc-text">不要使用单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#封装条件语句"><span class="toc-text">封装条件语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#避免用反义条件判断"><span class="toc-text">避免用反义条件判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#避免使用条件语句"><span class="toc-text">避免使用条件语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#避免类型检测-第-1-部分"><span class="toc-text">避免类型检测 (第 1 部分)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#避免类型检查（第-2-部分）"><span class="toc-text">避免类型检查（第 2 部分）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#移除无用代码"><span class="toc-text">移除无用代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象和数据结构"><span class="toc-text">对象和数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用对象封装"><span class="toc-text">使用对象封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#让对象拥有-private-protected-属性的成员"><span class="toc-text">让对象拥有 private/protected 属性的成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类"><span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#组合优于继承"><span class="toc-text">组合优于继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#避免流式接口"><span class="toc-text">避免流式接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SOLID"><span class="toc-text">SOLID</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#职责单一原则-Single-Responsibility-Principle-SRP"><span class="toc-text">职责单一原则 Single Responsibility Principle (SRP)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开闭原则-OCP"><span class="toc-text">开闭原则 (OCP)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#里氏代换原则-LSP"><span class="toc-text">里氏代换原则 (LSP)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口隔离原则-ISP"><span class="toc-text">接口隔离原则 (ISP)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#依赖反转原则-DIP"><span class="toc-text">依赖反转原则 (DIP)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#别写重复代码-DRY"><span class="toc-text">别写重复代码 (DRY)</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="PHP-代码简洁之道"><a href="#PHP-代码简洁之道" class="headerlink" title="PHP 代码简洁之道"></a>PHP 代码简洁之道</h2><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Robert C.Martin’s 的 软件工程师准则 <a href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882" target="_blank" rel="noopener"><em>Clean Code</em></a> 同样适用于 PHP。它并不是一个编码风格指南，它指导我们用 PHP 写出具有可读性，可复用性且可分解的代码。</p>
<p>并非所有的准则都必须严格遵守，甚至一些已经成为普遍的约定。这仅仅作为指导方针，其中许多都是 <em>Clean Code</em> 作者们多年来的经验。</p>
<blockquote>
<p>灵感来自于 <a href="https://github.com/ryanmcdermott/clean-code-javascript" target="_blank" rel="noopener">clean-code-javascript</a></p>
</blockquote>
<p>尽管许多开发者依旧使用 PHP 5 版本，但是这篇文章中绝大多数例子都是只能在 PHP 7.1 + 版本下运行。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="使用有意义的且可读的变量名"><a href="#使用有意义的且可读的变量名" class="headerlink" title="使用有意义的且可读的变量名"></a>使用有意义的且可读的变量名</h3><p><strong>不友好的：</strong></p>
<pre><code class="php">$ymdstr = $moment-&gt;format(&#39;y-m-d&#39;);</code></pre>
<p><strong>友好的：</strong></p>
<pre><code class="php">$currentDate = $moment-&gt;format(&#39;y-m-d&#39;);</code></pre>
<h3 id="对同类型的变量使用相同的词汇"><a href="#对同类型的变量使用相同的词汇" class="headerlink" title="对同类型的变量使用相同的词汇"></a>对同类型的变量使用相同的词汇</h3><p><strong>不友好的：</strong></p>
<pre><code class="php">getUserInfo();
getUserData();
getUserRecord();
getUserProfile();</code></pre>
<p><strong>友好的：</strong></p>
<pre><code class="php">getUser();</code></pre>
<h3 id="使用可搜索的名称（第一部分）"><a href="#使用可搜索的名称（第一部分）" class="headerlink" title="使用可搜索的名称（第一部分）"></a>使用可搜索的名称（第一部分）</h3><p>我们阅读的代码超过我们写的代码。所以我们写出的代码需要具备可读性、可搜索性，这一点非常重要。要我们去理解程序中没有名字的变量是非常头疼的。让你的变量可搜索吧！</p>
<p><strong>不具备可读性的代码：</strong></p>
<pre><code class="php">//  见鬼的 448 是什么意思？
$result = $serializer-&gt;serialize($data, 448);</code></pre>
<p><strong>具备可读性的：</strong></p>
<pre><code class="php">$json = $serializer-&gt;serialize($data, JSON_UNESCAPED_SLASHES | JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE);</code></pre>
<h3 id="使用可搜索的名称（第二部分）"><a href="#使用可搜索的名称（第二部分）" class="headerlink" title="使用可搜索的名称（第二部分）"></a>使用可搜索的名称（第二部分）</h3><p><strong>不好的：</strong></p>
<pre><code class="php">// 见鬼的 4 又是什么意思？
if ($user-&gt;access &amp; 4) {
    // ...
}</code></pre>
<p><strong>好的方式：</strong></p>
<pre><code class="php">class User
{
    const ACCESS_READ = 1;
    const ACCESS_CREATE = 2;
    const ACCESS_UPDATE = 4;
    const ACCESS_DELETE = 8;
}

if ($user-&gt;access &amp; User::ACCESS_UPDATE) {
    // do edit ...
}</code></pre>
<h3 id="使用解释性变量"><a href="#使用解释性变量" class="headerlink" title="使用解释性变量"></a>使用解释性变量</h3><p><strong>不好：</strong></p>
<pre><code class="php">$address = &#39;One Infinite Loop, Cupertino 95014&#39;;
$cityZipCodeRegex = &#39;/^[^,]+,\s*(.+?)\s*(\d{5})$/&#39;;
preg_match($cityZipCodeRegex, $address, $matches);

saveCityZipCode($matches[1], $matches[2]);</code></pre>
<p><strong>一般：</strong></p>
<p>这个好点，但我们仍严重依赖正则表达式。</p>
<pre><code class="php">$address = &#39;One Infinite Loop, Cupertino 95014&#39;;
$cityZipCodeRegex = &#39;/^[^,]+,\s*(.+?)\s*(\d{5})$/&#39;;
preg_match($cityZipCodeRegex, $address, $matches);

[, $city, $zipCode] = $matches;
saveCityZipCode($city, $zipCode);</code></pre>
<p><strong>很棒：</strong></p>
<p>通过命名子模式减少对正则表达式的依赖。</p>
<pre><code class="php">$address = &#39;One Infinite Loop, Cupertino 95014&#39;;
$cityZipCodeRegex = &#39;/^[^,]+,\s*(?&lt;city&gt;.+?)\s*(?&lt;zipCode&gt;\d{5})$/&#39;;
preg_match($cityZipCodeRegex, $address, $matches);

saveCityZipCode($matches[&#39;city&#39;], $matches[&#39;zipCode&#39;]);</code></pre>
<h3 id="避免嵌套太深和提前返回-第一部分"><a href="#避免嵌套太深和提前返回-第一部分" class="headerlink" title="避免嵌套太深和提前返回 (第一部分)"></a>避免嵌套太深和提前返回 (第一部分)</h3><p>使用太多 <code>if else</code> 表达式会导致代码难以理解。<br>明确优于隐式。</p>
<p><strong>不好:</strong></p>
<pre><code class="php">function isShopOpen($day): bool
{
    if ($day) {
        if (is_string($day)) {
            $day = strtolower($day);
            if ($day === &#39;friday&#39;) {
                return true;
            } elseif ($day === &#39;saturday&#39;) {
                return true;
            } elseif ($day === &#39;sunday&#39;) {
                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    } else {
        return false;
    }
}</code></pre>
<p><strong>很棒：</strong></p>
<pre><code class="php">function isShopOpen(string $day): bool
{
    if (empty($day)) {
        return false;
    }

    $openingDays = [
        &#39;friday&#39;, &#39;saturday&#39;, &#39;sunday&#39;
    ];

    return in_array(strtolower($day), $openingDays, true);
}</code></pre>
<h3 id="避免嵌套太深和提前返回-第二部分"><a href="#避免嵌套太深和提前返回-第二部分" class="headerlink" title="避免嵌套太深和提前返回 (第二部分)"></a>避免嵌套太深和提前返回 (第二部分)</h3><p><strong>不好：</strong></p>
<pre><code class="php">function fibonacci(int $n)
{
    if ($n &lt; 50) {
        if ($n !== 0) {
            if ($n !== 1) {
                return fibonacci($n - 1) + fibonacci($n - 2);
            } else {
                return 1;
            }
        } else {
            return 0;
        }
    } else {
        return &#39;Not supported&#39;;
    }
}</code></pre>
<p><strong>很棒：</strong></p>
<pre><code class="php">function fibonacci(int $n): int
{
    if ($n === 0 || $n === 1) {
        return $n;
    }

    if ($n &gt; 50) {
        throw new \Exception(&#39;Not supported&#39;);
    }

    return fibonacci($n - 1) + fibonacci($n - 2);
}</code></pre>
<h3 id="避免心理映射"><a href="#避免心理映射" class="headerlink" title="避免心理映射"></a>避免心理映射</h3><p>不要迫使你的代码阅读者翻译变量的意义。<br>明确优于隐式。</p>
<p><strong>不好：</strong></p>
<pre><code class="php">$l = [&#39;Austin&#39;, &#39;New York&#39;, &#39;San Francisco&#39;];

for ($i = 0; $i &lt; count($l); $i++) {
    $li = $l[$i];
    doStuff();
    doSomeOtherStuff();
    // ...
    // ...
    // ...
    // Wait, what is `$li` for again?
    dispatch($li);
}</code></pre>
<p><strong>很棒：</strong></p>
<pre><code class="php">$locations = [&#39;Austin&#39;, &#39;New York&#39;, &#39;San Francisco&#39;];

foreach ($locations as $location) {
    doStuff();
    doSomeOtherStuff();
    // ...
    // ...
    // ...
    dispatch($location);
}</code></pre>
<h3 id="不要增加不需要的上下文"><a href="#不要增加不需要的上下文" class="headerlink" title="不要增加不需要的上下文"></a>不要增加不需要的上下文</h3><p>如果类名或对象名告诉你某些东西后，请不要在变量名中重复。</p>
<p><strong>小坏坏：</strong></p>
<pre><code class="php">class Car
{
    public $carMake;
    public $carModel;
    public $carColor;

    //...
}</code></pre>
<p><strong>好的方式：</strong></p>
<pre><code class="php">class Car
{
    public $make;
    public $model;
    public $color;

    //...
}</code></pre>
<h3 id="使用默认参数而不是使用短路运算或者是条件判断"><a href="#使用默认参数而不是使用短路运算或者是条件判断" class="headerlink" title="使用默认参数而不是使用短路运算或者是条件判断"></a>使用默认参数而不是使用短路运算或者是条件判断</h3><p><strong>不好的做法:</strong></p>
<p>这是不太好的因为 <code>$breweryName</code> 可以是 <code>NULL</code>.</p>
<pre><code class="php">function createMicrobrewery($breweryName = &#39;Hipster Brew Co.&#39;): void
{
    // ...
}</code></pre>
<p><strong>还算可以的做法:</strong></p>
<p>这个做法比上面的更加容易理解，但是它需要很好的去控制变量的值.</p>
<pre><code class="php">function createMicrobrewery($name = null): void
{
    $breweryName = $name ?: &#39;Hipster Brew Co.&#39;;
    // ...
}</code></pre>
<p><strong>好的做法:</strong></p>
<p>你可以使用 <a href="http://php.net/manual/en/functions.arguments.php#functions.arguments.type-declaration" target="_blank" rel="noopener">类型提示</a> 而且可以保证 <code>$breweryName</code> 不会为空 <code>NULL</code>.</p>
<pre><code class="php">function createMicrobrewery(string $breweryName = &#39;Hipster Brew Co.&#39;): void
{
    // ...
}</code></pre>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><h3 id="使用-相等运算符"><a href="#使用-相等运算符" class="headerlink" title="使用 相等运算符"></a>使用 <a href="http://php.net/manual/en/language.operators.comparison.php" target="_blank" rel="noopener">相等运算符</a></h3><p><strong>不好的做法:</strong></p>
<pre><code class="php">$a = &#39;42&#39;;
$b = 42;
使用简单的相等运算符会把字符串类型转换成数字类型

if( $a != $b ) {
   //这个条件表达式总是会通过
}</code></pre>
<p>表达式 $a != $b 会返回 false 但实际上它应该是 true !<br>字符串类型 ‘42’ 是不同于数字类型的 42</p>
<p><strong>好的做法:</strong><br>使用全等运算符会对比类型和值</p>
<pre><code class="php">if( $a !== $b ) {
    //这个条件是通过的
}</code></pre>
<p>表达式 $a !== $b 会返回 true。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数参数（2-个或更少）"><a href="#函数参数（2-个或更少）" class="headerlink" title="函数参数（2 个或更少）"></a>函数参数（2 个或更少）</h3><p>限制函数参数个数极其重要<br>这样测试你的函数容易点。有超过 3 个可选参数会导致一个爆炸式组合增长，你会有成吨独立参数情形要测试。</p>
<p>无参数是理想情况。1 个或 2 个都可以，最好避免 3 个。<br>再多就需要加固了。通常如果你的函数有超过两个参数，说明他要处理的事太多了。 如果必须要传入很多数据，建议封装一个高级别对象作为参数。</p>
<p><strong>不友好的:</strong></p>
<pre><code class="php">function createMenu(string $title, string $body, string $buttonText, bool $cancellable): void
{
    // ...
}</code></pre>
<p><strong>友好的:</strong></p>
<pre><code class="php">class MenuConfig
{
    public $title;
    public $body;
    public $buttonText;
    public $cancellable = false;
}

$config = new MenuConfig();
$config-&gt;title = &#39;Foo&#39;;
$config-&gt;body = &#39;Bar&#39;;
$config-&gt;buttonText = &#39;Baz&#39;;
$config-&gt;cancellable = true;

function createMenu(MenuConfig $config): void
{
    // ...
}</code></pre>
<h3 id="函数应该只做一件事情"><a href="#函数应该只做一件事情" class="headerlink" title="函数应该只做一件事情"></a>函数应该只做一件事情</h3><p>这是迄今为止软件工程最重要的原则。函数做了超过一件事情时，它们将变得难以编写、测试、推导。 而函数只做一件事情时，重构起来则非常简单，同时代码阅读起来也非常清晰。掌握了这个原则，你就会领先许多其他的开发者。</p>
<p><strong>不好的:</strong></p>
<pre><code class="php">function emailClients(array $clients): void
{
    foreach ($clients as $client) {
        $clientRecord = $db-&gt;find($client);
        if ($clientRecord-&gt;isActive()) {
            email($client);
        }
    }
}</code></pre>
<p><strong>好的:</strong></p>
<pre><code class="php">function emailClients(array $clients): void
{
    $activeClients = activeClients($clients);
    array_walk($activeClients, &#39;email&#39;);
}

function activeClients(array $clients): array
{
    return array_filter($clients, &#39;isClientActive&#39;);
}

function isClientActive(int $client): bool
{
    $clientRecord = $db-&gt;find($client);

    return $clientRecord-&gt;isActive();
}</code></pre>
<h3 id="函数的名称要说清楚它做什么"><a href="#函数的名称要说清楚它做什么" class="headerlink" title="函数的名称要说清楚它做什么"></a>函数的名称要说清楚它做什么</h3><p><strong>不好的例子:</strong></p>
<pre><code class="php">class Email
{
    //...

    public function handle(): void
    {
        mail($this-&gt;to, $this-&gt;subject, $this-&gt;body);
    }
}

$message = new Email(...);
// What is this? A handle for the message? Are we writing to a file now?
$message-&gt;handle();</code></pre>
<p><strong>很好的例子:</strong></p>
<pre><code class="php">class Email 
{
    //...

    public function send(): void
    {
        mail($this-&gt;to, $this-&gt;subject, $this-&gt;body);
    }
}

$message = new Email(...);
// Clear and obvious
$message-&gt;send();</code></pre>
<h3 id="函数只能是一个抽象级别"><a href="#函数只能是一个抽象级别" class="headerlink" title="函数只能是一个抽象级别"></a>函数只能是一个抽象级别</h3><p>当你有多个抽象层次时，你的函数功能通常是做太多了。 分割函数功能使得重用性和测试更加容易。.</p>
<p><strong>不好:</strong></p>
<pre><code class="php">function parseBetterJSAlternative(string $code): void
{
    $regexes = [
        // ...
    ];

    $statements = explode(&#39; &#39;, $code);
    $tokens = [];
    foreach ($regexes as $regex) {
        foreach ($statements as $statement) {
            // ...
        }
    }

    $ast = [];
    foreach ($tokens as $token) {
        // lex...
    }

    foreach ($ast as $node) {
        // parse...
    }
}</code></pre>
<p><strong>同样不是很好:</strong></p>
<p>我们已经完成了一些功能，但是 <code>parseBetterJSAlternative()</code> 功能仍然非常复杂，测试起来也比较麻烦。</p>
<pre><code class="php">function tokenize(string $code): array
{
    $regexes = [
        // ...
    ];

    $statements = explode(&#39; &#39;, $code);
    $tokens = [];
    foreach ($regexes as $regex) {
        foreach ($statements as $statement) {
            $tokens[] = /* ... */;
        }
    }

    return $tokens;
}

function lexer(array $tokens): array
{
    $ast = [];
    foreach ($tokens as $token) {
        $ast[] = /* ... */;
    }

    return $ast;
}

function parseBetterJSAlternative(string $code): void
{
    $tokens = tokenize($code);
    $ast = lexer($tokens);
    foreach ($ast as $node) {
        // parse...
    }
}</code></pre>
<p><strong>很好的:</strong></p>
<p>最好的解决方案是取出 <code>parseBetterJSAlternative()</code> 函数的依赖关系.</p>
<pre><code class="php">class Tokenizer
{
    public function tokenize(string $code): array
    {
        $regexes = [
            // ...
        ];

        $statements = explode(&#39; &#39;, $code);
        $tokens = [];
        foreach ($regexes as $regex) {
            foreach ($statements as $statement) {
                $tokens[] = /* ... */;
            }
        }

        return $tokens;
    }
}

class Lexer
{
    public function lexify(array $tokens): array
    {
        $ast = [];
        foreach ($tokens as $token) {
            $ast[] = /* ... */;
        }

        return $ast;
    }
}

class BetterJSAlternative
{
    private $tokenizer;
    private $lexer;

    public function __construct(Tokenizer $tokenizer, Lexer $lexer)
    {
        $this-&gt;tokenizer = $tokenizer;
        $this-&gt;lexer = $lexer;
    }

    public function parse(string $code): void
    {
        $tokens = $this-&gt;tokenizer-&gt;tokenize($code);
        $ast = $this-&gt;lexer-&gt;lexify($tokens);
        foreach ($ast as $node) {
            // parse...
        }
    }
}</code></pre>
<h3 id="不要用标示作为函数的参数"><a href="#不要用标示作为函数的参数" class="headerlink" title="不要用标示作为函数的参数"></a>不要用标示作为函数的参数</h3><p>标示就是在告诉大家，这个方法里处理很多事。前面刚说过，一个函数应当只做一件事。 把不同标示的代码拆分到多个函数里。</p>
<p><strong>不友好的:</strong></p>
<pre><code class="php">function createFile(string $name, bool $temp = false): void
{
    if ($temp) {
        touch(&#39;./temp/&#39;.$name);
    } else {
        touch($name);
    }
}</code></pre>
<p><strong>友好的:</strong></p>
<pre><code class="php">function createFile(string $name): void
{
    touch($name);
}

function createTempFile(string $name): void
{
    touch(&#39;./temp/&#39;.$name);
}</code></pre>
<h3 id="避免副作用"><a href="#避免副作用" class="headerlink" title="避免副作用"></a>避免副作用</h3><p>一个函数应该只获取数值，然后返回另外的数值，如果在这个过程中还做了其他的事情，我们就称为副作用。副作用可能是写入一个文件，修改某些全局变量，或者意外的把你全部的钱给了陌生人。</p>
<p>现在，你的确需要在一个程序或者场合里要有副作用，像之前的例子，你也许需要写一个文件。你需要做的是把你做这些的地方集中起来。不要用几个函数和类来写入一个特定的文件。只允许使用一个服务来单独实现。</p>
<p>重点是避免常见陷阱比如对象间共享无结构的数据、使用可以写入任何的可变数据类型、不集中去处理这些副作用。如果你做了这些你就会比大多数程序员快乐。</p>
<p><strong>不好的:</strong></p>
<pre><code class="php">// 这个全局变量在函数中被使用
// 如果我们在别的方法中使用这个全局变量，有可能我们会不小心将其修改为数组类型
$name = &#39;Ryan McDermott&#39;;

function splitIntoFirstAndLastName(): void
{
    global $name;

    $name = explode(&#39; &#39;, $name);
}

splitIntoFirstAndLastName();

var_dump($name); // [&#39;Ryan&#39;, &#39;McDermott&#39;];</code></pre>
<p><strong>推荐的:</strong></p>
<pre><code class="php">function splitIntoFirstAndLastName(string $name): array
{
    return explode(&#39; &#39;, $name);
}

$name = &#39;Ryan McDermott&#39;;
$newName = splitIntoFirstAndLastName($name);

var_dump($name); // &#39;Ryan McDermott&#39;;
var_dump($newName); // [&#39;Ryan&#39;, &#39;McDermott&#39;];</code></pre>
<h3 id="不要定义全局函数"><a href="#不要定义全局函数" class="headerlink" title="不要定义全局函数"></a>不要定义全局函数</h3><p>在很多语言中定义全局函数是一个坏习惯，因为你定义的全局函数可能与其他人的函数库冲突，并且，除非在实际运用中遇到异常，否则你的 API 的使用者将无法觉察到这一点。接下来我们来看看一个例子：当你想有一个配置数组，你可能会写一个 <code>config()</code> 的全局函数，但是这样会与其他人定义的库冲突。</p>
<p><strong>不好的:</strong></p>
<pre><code class="php">function config(): array
{
    return  [
        &#39;foo&#39; =&gt; &#39;bar&#39;,
    ]
}</code></pre>
<p><strong>好的:</strong></p>
<pre><code class="php">class Configuration
{
    private $configuration = [];

    public function __construct(array $configuration)
    {
        $this-&gt;configuration = $configuration;
    }

    public function get(string $key): ?string
    {
        return isset($this-&gt;configuration[$key]) ? $this-&gt;configuration[$key] : null;
    }
}</code></pre>
<p>获取配置需要先创建 <code>Configuration</code> 类的实例，如下：</p>
<pre><code class="php">$configuration = new Configuration([
    &#39;foo&#39; =&gt; &#39;bar&#39;,
]);</code></pre>
<p>现在，在你的应用中必须使用 <code>Configuration</code> 的实例了。</p>
<h3 id="不要使用单例模式"><a href="#不要使用单例模式" class="headerlink" title="不要使用单例模式"></a>不要使用单例模式</h3><p>单例模式是个 <a href="https://en.wikipedia.org/wiki/Singleton_pattern" target="_blank" rel="noopener">反模式</a>。 以下转述 Brian Button 的观点：</p>
<ol>
<li>单例模式常用于 <strong>全局实例</strong>， 这么做为什么不好呢？ 因为在你的代码里 <strong>你隐藏了应用的依赖关系</strong>，而没有通过接口公开依赖关系 。避免全局的东西扩散使用是一种 <a href="https://en.wikipedia.org/wiki/Code_smell" target="_blank" rel="noopener">代码味道</a>.</li>
<li>单例模式违反了 <a href="https://learnku.com/laravel/t/7774/the-conciseness-of-the-php-code-php-clean-code#single-responsibility-principle-srp" target="_blank" rel="noopener">单一责任原则</a>： 依据的事实就是 <strong>单例模式自己控制自身的创建和生命周期</strong>.</li>
<li>单例模式天生就导致代码紧 <a href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)" target="_blank" rel="noopener">耦合</a>。这使得在许多情况下用伪造的数据 <strong>难于测试</strong>。</li>
<li>单例模式的状态会留存于应用的整个生命周期。 这会对测试产生第二次打击，<strong>你只能让被严令需要测试的代码运行不了</strong>收场，根本不能进行单元测试。为何？因为每一个单元测试应该彼此独立。</li>
</ol>
<p>还有些来自 <a href="http://misko.hevery.com/about/" target="_blank" rel="noopener">Misko Hevery</a> 的深入思考，关于单例模式的 <a href="http://misko.hevery.com/2008/08/25/root-cause-of-singletons/" target="_blank" rel="noopener">问题根源</a>。</p>
<p><strong>不好的示范：</strong></p>
<pre><code class="php">class DBConnection
{
    private static $instance;

    private function __construct(string $dsn)
    {
        // ...
    }

    public static function getInstance(): DBConnection
    {
        if (self::$instance === null) {
            self::$instance = new self();
        }

        return self::$instance;
    }

    // ...
}

$singleton = DBConnection::getInstance();</code></pre>
<p><strong>好的示范：</strong></p>
<pre><code class="php">class DBConnection
{
    public function __construct(string $dsn)
    {
        // ...
    }

     // ...
}</code></pre>
<p>用 <a href="http://php.net/manual/en/pdo.construct.php#refsect1-pdo.construct-parameters" target="_blank" rel="noopener">DSN</a> 进行配置创建的 <code>DBConnection</code> 类实例。</p>
<pre><code class="php">$connection = new DBConnection($dsn);</code></pre>
<p>现在就必须在你的应用中使用 <code>DBConnection</code> 的实例了。</p>
<h3 id="封装条件语句"><a href="#封装条件语句" class="headerlink" title="封装条件语句"></a>封装条件语句</h3><p><strong>不友好的:</strong></p>
<pre><code class="php">if ($article-&gt;state === &#39;published&#39;) {
    // ...
}</code></pre>
<p><strong>友好的:</strong></p>
<pre><code class="php">if ($article-&gt;isPublished()) {
    // ...
}</code></pre>
<h3 id="避免用反义条件判断"><a href="#避免用反义条件判断" class="headerlink" title="避免用反义条件判断"></a>避免用反义条件判断</h3><p><strong>不友好的:</strong></p>
<pre><code class="php">function isDOMNodeNotPresent(\DOMNode $node): bool
{
    // ...
}

if (!isDOMNodeNotPresent($node))
{
    // ...
}</code></pre>
<p><strong>友好的:</strong></p>
<pre><code class="php">function isDOMNodePresent(\DOMNode $node): bool
{
    // ...
}

if (isDOMNodePresent($node)) {
    // ...
}</code></pre>
<h3 id="避免使用条件语句"><a href="#避免使用条件语句" class="headerlink" title="避免使用条件语句"></a>避免使用条件语句</h3><p>这听起来像是个不可能实现的任务。 当第一次听到这个时，大部分人都会说，“没有 <code>if</code> 语句，我该怎么办？” 答案就是在很多情况下你可以使用多态性来实现同样的任务。 接着第二个问题来了， “听着不错，但我为什么需要那样做？”，这个答案就是我们之前所学的干净代码概念：一个函数应该只做一件事情。如果你的类或函数有 <code>if</code> 语句，这就告诉了使用者你的类或函数干了不止一件事情。 记住，只要做一件事情。</p>
<p><strong>不好的:</strong></p>
<pre><code class="php">class Airplane
{
    // ...

    public function getCruisingAltitude(): int
    {
        switch ($this-&gt;type) {
            case &#39;777&#39;:
                return $this-&gt;getMaxAltitude() - $this-&gt;getPassengerCount();
            case &#39;Air Force One&#39;:
                return $this-&gt;getMaxAltitude();
            case &#39;Cessna&#39;:
                return $this-&gt;getMaxAltitude() - $this-&gt;getFuelExpenditure();
        }
    }
}</code></pre>
<p><strong>好的:</strong></p>
<pre><code class="php">interface Airplane
{
    // ...

    public function getCruisingAltitude(): int;
}

class Boeing777 implements Airplane
{
    // ...

    public function getCruisingAltitude(): int
    {
        return $this-&gt;getMaxAltitude() - $this-&gt;getPassengerCount();
    }
}

class AirForceOne implements Airplane
{
    // ...

    public function getCruisingAltitude(): int
    {
        return $this-&gt;getMaxAltitude();
    }
}

class Cessna implements Airplane
{
    // ...

    public function getCruisingAltitude(): int
    {
        return $this-&gt;getMaxAltitude() - $this-&gt;getFuelExpenditure();
    }
}</code></pre>
<h3 id="避免类型检测-第-1-部分"><a href="#避免类型检测-第-1-部分" class="headerlink" title="避免类型检测 (第 1 部分)"></a>避免类型检测 (第 1 部分)</h3><p>PHP 是无类型的，这意味着你的函数可以接受任何类型的参数。<br>有时这种自由会让你感到困扰，并且他会让你自然而然的在函数中使用类型检测。有很多方法可以避免这么做。<br>首先考虑 API 的一致性。</p>
<p><strong>不好的：</strong></p>
<pre><code class="php">function travelToTexas($vehicle): void
{
    if ($vehicle instanceof Bicycle) {
        $vehicle-&gt;pedalTo(new Location(&#39;texas&#39;));
    } elseif ($vehicle instanceof Car) {
        $vehicle-&gt;driveTo(new Location(&#39;texas&#39;));
    }
}</code></pre>
<p><strong>好的：</strong></p>
<pre><code class="php">function travelToTexas(Traveler $vehicle): void
{
    $vehicle-&gt;travelTo(new Location(&#39;texas&#39;));
}</code></pre>
<h3 id="避免类型检查（第-2-部分）"><a href="#避免类型检查（第-2-部分）" class="headerlink" title="避免类型检查（第 2 部分）"></a>避免类型检查（第 2 部分）</h3><p>如果你正在使用像 字符串、数值、或数组这样的基础类型，你使用的是 PHP 版本是 PHP 7+，并且你不能使用多态，但仍然觉得需要使用类型检测，这时，你应该考虑 <a href="http://php.net/manual/en/functions.arguments.php#functions.arguments.type-declaration" target="_blank" rel="noopener">类型定义</a> 或 严格模式。它为您提供了标准 PHP 语法之上的静态类型。<br>手动进行类型检查的问题是做这件事需要这么多的额外言辞，你所得到的虚假的『类型安全』并不能弥补丢失的可读性。保持你的代码简洁，编写良好的测试，并且拥有好的代码审查。<br>否则，使用 PHP 严格的类型声明或严格模式完成所有这些工作。</p>
<p><strong>不好的：</strong></p>
<pre><code class="php">function combine($val1, $val2): int
{
    if (!is_numeric($val1) || !is_numeric($val2)) {
        throw new \Exception(&#39;Must be of type Number&#39;);
    }

    return $val1 + $val2;
}</code></pre>
<p><strong>好的：</strong></p>
<pre><code class="php">function combine(int $val1, int $val2): int
{
    return $val1 + $val2;
}</code></pre>
<h3 id="移除无用代码"><a href="#移除无用代码" class="headerlink" title="移除无用代码"></a>移除无用代码</h3><p>无用代码和重复代码一样糟糕。 如果没有被调用，就应该把它删除掉，没必要将它保留在你的代码库中！当你需要它的时候，可以在你的历史版本中找到它。</p>
<p><strong>Bad:</strong></p>
<pre><code class="php">function oldRequestModule(string $url): void
{
    // ...
}

function newRequestModule(string $url): void
{
    // ...
}

$request = newRequestModule($requestUrl);
inventoryTracker(&#39;apples&#39;, $request, &#39;www.inventory-awesome.io&#39;);</code></pre>
<p><strong>Good:</strong></p>
<pre><code class="php">function requestModule(string $url): void
{
    // ...
}

$request = requestModule($requestUrl);
inventoryTracker(&#39;apples&#39;, $request, &#39;www.inventory-awesome.io&#39;);</code></pre>
<h2 id="对象和数据结构"><a href="#对象和数据结构" class="headerlink" title="对象和数据结构"></a>对象和数据结构</h2><h3 id="使用对象封装"><a href="#使用对象封装" class="headerlink" title="使用对象封装"></a>使用对象封装</h3><p>在 PHP 中，你可以在方法中使用关键字，如 <code>public</code>, <code>protected</code> and <code>private</code>。<br>使用它们，你可以任意的控制、修改对象的属性。</p>
<ul>
<li>当你除获取对象属性外还想做更多的操作时，你不需要修改你的代码</li>
<li>当 <code>set</code> 属性时，易于增加参数验证。</li>
<li>封装的内部表示。</li>
<li>容易在获取和设置属性时添加日志和错误处理。</li>
<li>继承这个类，你可以重写默认信息。</li>
<li>你可以延迟加载对象的属性，比如从服务器获取数据。</li>
</ul>
<p>此外，这样的方式也符合 OOP 开发中的 [开闭原则](# 开闭原则 (OCP))</p>
<p><strong>不好的:</strong></p>
<pre><code class="php">class BankAccount
{
    public $balance = 1000;
}

$bankAccount = new BankAccount();

// Buy shoes...
$bankAccount-&gt;balance -= 100;</code></pre>
<p><strong>好的:</strong></p>
<pre><code class="php">class BankAccount
{
    private $balance;

    public function __construct(int $balance = 1000)
    {
      $this-&gt;balance = $balance;
    }

    public function withdraw(int $amount): void
    {
        if ($amount &gt; $this-&gt;balance) {
            throw new \Exception(&#39;Amount greater than available balance.&#39;);
        }

        $this-&gt;balance -= $amount;
    }

    public function deposit(int $amount): void
    {
        $this-&gt;balance += $amount;
    }

    public function getBalance(): int
    {
        return $this-&gt;balance;
    }
}

$bankAccount = new BankAccount();

// Buy shoes...
$bankAccount-&gt;withdraw($shoesPrice);

// Get balance
$balance = $bankAccount-&gt;getBalance();</code></pre>
<h3 id="让对象拥有-private-protected-属性的成员"><a href="#让对象拥有-private-protected-属性的成员" class="headerlink" title="让对象拥有 private/protected 属性的成员"></a>让对象拥有 private/protected 属性的成员</h3><ul>
<li><code>public</code> 公有方法和属性对于变化来说是最危险的，因为一些外部的代码可能会轻易的依赖他们，但是你没法控制那些依赖他们的代码。 <strong>类的变化对于类的所有使用者来说都是危险的。</strong></li>
<li><code>protected</code> 受保护的属性变化和 public 公有的同样危险，因为他们在子类范围内是可用的。也就是说 public 和 protected 之间的区别仅仅在于访问机制，只有封装才能保证属性是一致的。<strong>任何在类内的变化对于所有继承子类来说都是危险的 。</strong></li>
<li><code>private</code> 私有属性的变化可以保证代码 <strong>只对单个类范围内的危险</strong> (对于修改你是安全的，并且你不会有其他类似堆积木的影响 <a href="http://www.urbandictionary.com/define.php?term=Jengaphobia&defid=2494196" target="_blank" rel="noopener">Jenga effect</a>).</li>
</ul>
<p>因此，请默认使用 <code>private</code> 属性，只有当需要对外部类提供访问属性的时候才采用 <code>public/protected</code> 属性。</p>
<p>更多的信息可以参考 <a href="https://github.com/fabpot" target="_blank" rel="noopener">Fabien Potencier</a> 写的针对这个专栏的文章 <a href="http://fabien.potencier.org/pragmatism-over-theory-protected-vs-private.html" target="_blank" rel="noopener">blog post</a> .</p>
<p><strong>Bad:</strong></p>
<pre><code class="php">class Employee
{
    public $name;

    public function __construct(string $name)
    {
        $this-&gt;name = $name;
    }
}

$employee = new Employee(&#39;John Doe&#39;);
echo &#39;Employee name: &#39;.$employee-&gt;name; // Employee name: John Doe</code></pre>
<p><strong>Good:</strong></p>
<pre><code class="php">class Employee
{
    private $name;

    public function __construct(string $name)
    {
        $this-&gt;name = $name;
    }

    public function getName(): string
    {
        return $this-&gt;name;
    }
}

$employee = new Employee(&#39;John Doe&#39;);
echo &#39;Employee name: &#39;.$employee-&gt;getName(); // Employee name: John Doe</code></pre>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="组合优于继承"><a href="#组合优于继承" class="headerlink" title="组合优于继承"></a>组合优于继承</h3><p>正如 the Gang of Four 所著的 <a href="https://en.wikipedia.org/wiki/Design_Patterns" target="_blank" rel="noopener"><em>设计模式</em></a> 中所说，<br>我们应该尽量优先选择组合而不是继承的方式。使用继承和组合都有很多好处。<br>这个准则的主要意义在于当你本能的使用继承时，试着思考一下<strong>组合</strong>是否能更好对你的需求建模。<br>在一些情况下，是这样的。</p>
<p>接下来你或许会想，“那我应该在什么时候使用继承？”<br>答案依赖于你的问题，当然下面有一些何时继承比组合更好的说明：</p>
<ol>
<li>你的继承表达了 “是一个” 而不是 “有一个” 的关系（例如人类 “是” 动物，而用户 “有” 用户详情）。</li>
<li>你可以复用基类的代码（人类可以像动物一样移动）。</li>
<li>你想通过修改基类对所有派生类做全局的修改（当动物移动时，修改它们的能量消耗）。</li>
</ol>
<p><strong>糟糕的:</strong></p>
<pre><code class="php">class Employee 
{
    private $name;
    private $email;

    public function __construct(string $name, string $email)
    {
        $this-&gt;name = $name;
        $this-&gt;email = $email;
    }

    // ...
}

// 不好，因为Employees &quot;有&quot; taxdata
// 而EmployeeTaxData不是Employee类型的

class EmployeeTaxData extends Employee 
{
    private $ssn;
    private $salary;

    public function __construct(string $name, string $email, string $ssn, string $salary)
    {
        parent::__construct($name, $email);

        $this-&gt;ssn = $ssn;
        $this-&gt;salary = $salary;
    }

    // ...
}</code></pre>
<p><strong>棒棒哒:</strong></p>
<pre><code class="php">class EmployeeTaxData 
{
    private $ssn;
    private $salary;

    public function __construct(string $ssn, string $salary)
    {
        $this-&gt;ssn = $ssn;
        $this-&gt;salary = $salary;
    }

    // ...
}

class Employee 
{
    private $name;
    private $email;
    private $taxData;

    public function __construct(string $name, string $email)
    {
        $this-&gt;name = $name;
        $this-&gt;email = $email;
    }

    public function setTaxData(string $ssn, string $salary)
    {
        $this-&gt;taxData = new EmployeeTaxData($ssn, $salary);
    }

    // ...
}</code></pre>
<h3 id="避免流式接口"><a href="#避免流式接口" class="headerlink" title="避免流式接口"></a>避免流式接口</h3><p><a href="https://en.wikipedia.org/wiki/Fluent_interface" target="_blank" rel="noopener">流式接口</a> 是一种面向对象 API 的方法，旨在通过方法链 <a href="https://en.wikipedia.org/wiki/Method_chaining" target="_blank" rel="noopener">Method chaining</a> 来提高源代码的可阅读性.</p>
<p>流式接口虽然需要一些上下文，需要经常构建对象，但是这种模式减少了代码的冗余度 (例如： <a href="https://phpunit.de/manual/current/en/test-doubles.html" target="_blank" rel="noopener">PHPUnit Mock Builder</a><br>或 <a href="http://docs.doctrine-project.org/projects/doctrine-dbal/en/latest/reference/query-builder.html" target="_blank" rel="noopener">Doctrine Query Builder</a>)</p>
<p>但是同样它也带来了很多麻烦:</p>
<ol>
<li>破坏了封装 <a href="https://en.wikipedia.org/wiki/Encapsulation_(object-oriented_programming)" target="_blank" rel="noopener">Encapsulation</a></li>
<li>破坏了原型 <a href="https://en.wikipedia.org/wiki/Decorator_pattern" target="_blank" rel="noopener">Decorators</a></li>
<li>难以模拟测试 <a href="https://en.wikipedia.org/wiki/Mock_object" target="_blank" rel="noopener">mock</a></li>
<li>使得多次提交的代码难以理解</li>
</ol>
<p>更多信息可以参考 <a href="https://github.com/Ocramius" target="_blank" rel="noopener">Marco Pivetta</a> 撰写的关于这个专题的文章 <a href="https://ocramius.github.io/blog/fluent-interfaces-are-evil/" target="_blank" rel="noopener">blog post</a></p>
<p><strong>Bad:</strong></p>
<pre><code class="php">class Car
{
    private $make = &#39;Honda&#39;;
    private $model = &#39;Accord&#39;;
    private $color = &#39;white&#39;;

    public function setMake(string $make): self
    {
        $this-&gt;make = $make;

        // NOTE: Returning this for chaining
        return $this;
    }

    public function setModel(string $model): self
    {
        $this-&gt;model = $model;

        // NOTE: Returning this for chaining
        return $this;
    }

    public function setColor(string $color): self
    {
        $this-&gt;color = $color;

        // NOTE: Returning this for chaining
        return $this;
    }

    public function dump(): void
    {
        var_dump($this-&gt;make, $this-&gt;model, $this-&gt;color);
    }
}

$car = (new Car())
  -&gt;setColor(&#39;pink&#39;)
  -&gt;setMake(&#39;Ford&#39;)
  -&gt;setModel(&#39;F-150&#39;)
  -&gt;dump();</code></pre>
<p><strong>Good:</strong></p>
<pre><code class="php">class Car
{
    private $make = &#39;Honda&#39;;
    private $model = &#39;Accord&#39;;
    private $color = &#39;white&#39;;

    public function setMake(string $make): void
    {
        $this-&gt;make = $make;
    }

    public function setModel(string $model): void
    {
        $this-&gt;model = $model;
    }

    public function setColor(string $color): void
    {
        $this-&gt;color = $color;
    }

    public function dump(): void
    {
        var_dump($this-&gt;make, $this-&gt;model, $this-&gt;color);
    }
}

$car = new Car();
$car-&gt;setColor(&#39;pink&#39;);
$car-&gt;setMake(&#39;Ford&#39;);
$car-&gt;setModel(&#39;F-150&#39;);
$car-&gt;dump();</code></pre>
<h2 id="SOLID"><a href="#SOLID" class="headerlink" title="SOLID"></a>SOLID</h2><p><strong>SOLID</strong> 是 Michael Feathers 推荐的便于记忆的首字母简写，它代表了 Robert Martin 命名的最重要的五个面向对象编程设计原则：</p>
<ul>
<li><a href="https://learnku.com/laravel/t/7774/the-conciseness-of-the-php-code-php-clean-code#single-responsibility-principle-srp" target="_blank" rel="noopener">S: 职责单一原则 (SRP)</a></li>
<li><a href="https://learnku.com/laravel/t/7774/the-conciseness-of-the-php-code-php-clean-code#openclosed-principle-ocp" target="_blank" rel="noopener">O: 开闭原则 (OCP)</a></li>
<li><a href="https://learnku.com/laravel/t/7774/the-conciseness-of-the-php-code-php-clean-code#liskov-substitution-principle-lsp" target="_blank" rel="noopener">L: 里氏替换原则 (LSP)</a></li>
<li><a href="https://learnku.com/laravel/t/7774/the-conciseness-of-the-php-code-php-clean-code#interface-segregation-principle-isp" target="_blank" rel="noopener">I: 接口隔离原则 (ISP)</a></li>
<li><a href="https://learnku.com/laravel/t/7774/the-conciseness-of-the-php-code-php-clean-code#dependency-inversion-principle-dip" target="_blank" rel="noopener">D: 依赖反转原则 (DIP)</a></li>
</ul>
<h3 id="职责单一原则-Single-Responsibility-Principle-SRP"><a href="#职责单一原则-Single-Responsibility-Principle-SRP" class="headerlink" title="职责单一原则 Single Responsibility Principle (SRP)"></a>职责单一原则 Single Responsibility Principle (SRP)</h3><p>正如 <em>Clean Code</em> 书中所述，”修改一个类应该只为一个理由”。人们总是容易去用一堆方法 “塞满” 一个类，就好像当我们坐飞机上只能携带一个行李箱时，会把所有的东西都塞到这个箱子里。这样做带来的后果是：从逻辑上讲，这样的类不是高内聚的，并且留下了很多以后去修改它的理由。<br>将你需要修改类的次数降低到最小很重要，这是因为，当类中有很多方法时，修改某一处，你很难知晓在整个代码库中有哪些依赖于此的模块会被影响。</p>
<p><strong>比较糟:</strong></p>
<pre><code class="php">class UserSettings
{
    private $user;

    public function __construct(User $user)
    {
        $this-&gt;user = $user;
    }

    public function changeSettings(array $settings): void
    {
        if ($this-&gt;verifyCredentials()) {
            // ...
        }
    }

    private function verifyCredentials(): bool
    {
        // ...
    }
}</code></pre>
<p><strong>棒棒哒:</strong></p>
<pre><code class="php">class UserAuth 
{
    private $user;

    public function __construct(User $user)
    {
        $this-&gt;user = $user;
    }

    public function verifyCredentials(): bool
    {
        // ...
    }
}

class UserSettings 
{
    private $user;
    private $auth;

    public function __construct(User $user) 
    {
        $this-&gt;user = $user;
        $this-&gt;auth = new UserAuth($user);
    }

    public function changeSettings(array $settings): void
    {
        if ($this-&gt;auth-&gt;verifyCredentials()) {
            // ...
        }
    }
}</code></pre>
<h3 id="开闭原则-OCP"><a href="#开闭原则-OCP" class="headerlink" title="开闭原则 (OCP)"></a>开闭原则 (OCP)</h3><p>如 Bertrand Meyer 所述，”软件实体 (类，模块，功能，等) 应该对扩展开放，但对修改关闭.” 这意味着什么？这个原则大体上是指你应该允许用户在不修改已有代码情况下添加功能.</p>
<p><strong>坏的:</strong></p>
<pre><code class="php">abstract class Adapter
{
    protected $name;

    public function getName(): string
    {
        return $this-&gt;name;
    }
}

class AjaxAdapter extends Adapter
{
    public function __construct()
    {
        parent::__construct();

        $this-&gt;name = &#39;ajaxAdapter&#39;;
    }
}

class NodeAdapter extends Adapter
{
    public function __construct()
    {
        parent::__construct();

        $this-&gt;name = &#39;nodeAdapter&#39;;
    }
}

class HttpRequester
{
    private $adapter;

    public function __construct(Adapter $adapter)
    {
        $this-&gt;adapter = $adapter;
    }

    public function fetch(string $url): Promise
    {
        $adapterName = $this-&gt;adapter-&gt;getName();

        if ($adapterName === &#39;ajaxAdapter&#39;) {
            return $this-&gt;makeAjaxCall($url);
        } elseif ($adapterName === &#39;httpNodeAdapter&#39;) {
            return $this-&gt;makeHttpCall($url);
        }
    }

    private function makeAjaxCall(string $url): Promise
    {
        // request and return promise
    }

    private function makeHttpCall(string $url): Promise
    {
        // request and return promise
    }
}</code></pre>
<p><strong>好的:</strong></p>
<pre><code class="php">interface Adapter
{
    public function request(string $url): Promise;
}

class AjaxAdapter implements Adapter
{
    public function request(string $url): Promise
    {
        // request and return promise
    }
}

class NodeAdapter implements Adapter
{
    public function request(string $url): Promise
    {
        // request and return promise
    }
}

class HttpRequester
{
    private $adapter;

    public function __construct(Adapter $adapter)
    {
        $this-&gt;adapter = $adapter;
    }

    public function fetch(string $url): Promise
    {
        return $this-&gt;adapter-&gt;request($url);
    }
}</code></pre>
<h3 id="里氏代换原则-LSP"><a href="#里氏代换原则-LSP" class="headerlink" title="里氏代换原则 (LSP)"></a>里氏代换原则 (LSP)</h3><p>这是一个简单概念的可怕术语。它通常被定义为 “如果 S 是 T 的一个子类型，则 T 型对象可以替换为 S 型对象”<br>(i.e., S 类型的对象可以替换 T 型对象) 在不改变程序的任何理想属性的情况下 (正确性，任务完成度，etc.).” 这是一个更可怕的定义.<br>这个的最佳解释是，如果你有个父类和一个子类，然后父类和子类可以互换使用而不会得到不正确的结果。这或许依然令人疑惑，所以我们来看下经典的正方形 - 矩形例子。几何定义，正方形是矩形，但是，如果你通过继承建立了 “IS-a” 关系的模型，你很快就会陷入麻烦。.</p>
<p><strong>不好的:</strong></p>
<pre><code class="php">class Rectangle
{
    protected $width = 0;
    protected $height = 0;

    public function render(int $area): void
    {
        // ...
    }

    public function setWidth(int $width): void
    {
        $this-&gt;width = $width;
    }

    public function setHeight(int $height): void
    {
        $this-&gt;height = $height;
    }

    public function getArea(): int
    {
        return $this-&gt;width * $this-&gt;height;
    }
}

class Square extends Rectangle
{
    public function setWidth(int $width): void
    {
        $this-&gt;width = $this-&gt;height = $width;
    }

    public function setHeight(int $height): void
    {
        $this-&gt;width = $this-&gt;height = $height;
    }
}

/**
 * @param Rectangle[] $rectangles
 */
function renderLargeRectangles(array $rectangles): void
{
    foreach ($rectangles as $rectangle) {
        $rectangle-&gt;setWidth(4);
        $rectangle-&gt;setHeight(5);
        $area = $rectangle-&gt;getArea(); // BAD: Will return 25 for Square. Should be 20.
        $rectangle-&gt;render($area);
    }
}

$rectangles = [new Rectangle(), new Rectangle(), new Square()];
renderLargeRectangles($rectangles);</code></pre>
<p><strong>优秀的:</strong></p>
<pre><code class="php">abstract class Shape
{
    abstract public function getArea(): int;

    public function render(int $area): void
    {
        // ...
    }
}

class Rectangle extends Shape
{
    private $width;
    private $height;

    public function __construct(int $width, int $height)
    {
        $this-&gt;width = $width;
        $this-&gt;height = $height;
    }

    public function getArea(): int
    {
        return $this-&gt;width * $this-&gt;height;
    }
}

class Square extends Shape
{
    private $length;

    public function __construct(int $length)
    {
        $this-&gt;length = $length;
    }

    public function getArea(): int
    {
        return pow($this-&gt;length, 2);
    }
}

/**
 * @param Rectangle[] $rectangles
 */
function renderLargeRectangles(array $rectangles): void
{
    foreach ($rectangles as $rectangle) {
        $area = $rectangle-&gt;getArea(); 
        $rectangle-&gt;render($area);
    }
}

$shapes = [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];
renderLargeRectangles($shapes);</code></pre>
<h3 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则 (ISP)"></a>接口隔离原则 (ISP)</h3><p>ISP 指出 “客户不应该被强制依赖于他们用不到的接口.”</p>
<p>一个好的例子来观察证实此原则的是针对需要大量设置对象的类，不要求客户端设置大量的选项是有益的，因为多数情况下他们不需要所有的设置。使他们可选来避免产生一个 “臃肿的接口”.</p>
<p><strong>坏的:</strong></p>
<pre><code class="php">interface Employee
{
    public function work(): void;

    public function eat(): void;
}

class Human implements Employee
{
    public function work(): void
    {
        // ....working
    }

    public function eat(): void
    {
        // ...... eating in lunch break
    }
}

class Robot implements Employee
{
    public function work(): void
    {
        //.... working much more
    }

    public function eat(): void
    {
        //.... robot can&#39;t eat, but it must implement this method
    }
}</code></pre>
<p><strong>好的:</strong></p>
<p>并不是每个工人都是雇员，但每个雇员都是工人.</p>
<pre><code class="php">interface Workable
{
    public function work(): void;
}

interface Feedable
{
    public function eat(): void;
}

interface Employee extends Feedable, Workable
{
}

class Human implements Employee
{
    public function work(): void
    {
        // ....working
    }

    public function eat(): void
    {
        //.... eating in lunch break
    }
}

// robot can only work
class Robot implements Workable
{
    public function work(): void
    {
        // ....working
    }
}</code></pre>
<h3 id="依赖反转原则-DIP"><a href="#依赖反转原则-DIP" class="headerlink" title="依赖反转原则 (DIP)"></a>依赖反转原则 (DIP)</h3><p>这一原则规定了两项基本内容:</p>
<ol>
<li>高级模块不应依赖于低级模块。两者都应该依赖于抽象.</li>
<li>抽象类不应依赖于实例。实例应该依赖于抽象.</li>
</ol>
<p>一开始可能很难去理解，但是你如果工作中使用过 php 框架（如 Symfony）, 你应该见过以依赖的形式执行这一原则<br>依赖注入 (DI). 虽然他们不是相同的概念，DIP 可以让高级模块不需要了解其低级模块的详细信息而安装它们.<br>通过依赖注入可以做到。这样做的一个巨大好处是减少了模块之间的耦合。耦合是一种非常糟糕的开发模式，因为它使您的代码难以重构.</p>
<p><strong>不好的:</strong></p>
<pre><code class="php">class Employee
{
    public function work(): void
    {
        // ....working
    }
}

class Robot extends Employee
{
    public function work(): void
    {
        //.... working much more
    }
}

class Manager
{
    private $employee;

    public function __construct(Employee $employee)
    {
        $this-&gt;employee = $employee;
    }

    public function manage(): void
    {
        $this-&gt;employee-&gt;work();
    }
}</code></pre>
<p><strong>优秀的:</strong></p>
<pre><code class="php">interface Employee
{
    public function work(): void;
}

class Human implements Employee
{
    public function work(): void
    {
        // ....working
    }
}

class Robot implements Employee
{
    public function work(): void
    {
        //.... working much more
    }
}

class Manager
{
    private $employee;

    public function __construct(Employee $employee)
    {
        $this-&gt;employee = $employee;
    }

    public function manage(): void
    {
        $this-&gt;employee-&gt;work();
    }
}</code></pre>
<h2 id="别写重复代码-DRY"><a href="#别写重复代码-DRY" class="headerlink" title="别写重复代码 (DRY)"></a>别写重复代码 (DRY)</h2><p>试着去遵循 <a href="https://en.wikipedia.org/wiki/Don' target="_blank" rel="noopener"t_repeat_yourself">DRY</a> 原则。</p>
<p>尽你最大的努力去避免复制代码，它是一种非常糟糕的行为，复制代码通常意味着当你需要变更一些逻辑时，你需要修改不止一处。</p>
<p>试想一下，如果你在经营一家餐厅，并且你需要记录你仓库的进销记录：包括所有的土豆，洋葱，大蒜，辣椒，等等。如果你使用多个表格来管理进销记录，当你用其中一些土豆做菜时，你需要更新所有的表格。如果你只有一个列表的话就只需要更新一个地方。</p>
<p>通常情况下你复制代码的原因可能是它们大多数都是一样的，只不过有两个或者多个略微不同的逻辑，但是由于这些区别，最终导致你写出了两个或者多个隔离的但大部分相同的方法，移除重复的代码意味着用一个 function/module/class 创建一个能处理差异的抽象。</p>
<p>正确的抽象是非常关键的，这正是为什么你必须学习遵守在 <a href="https://learnku.com/laravel/t/7774/the-conciseness-of-the-php-code-php-clean-code#classes" target="_blank" rel="noopener">Classes</a> 章节展开讨论的的 <strong>SOLID</strong> 原则，不合理的抽象比复制代码更糟糕，所以请务必谨慎！说了这么多，如果你能设计一个合理的抽象，就去实现它！最后再说一遍，不要写重复代码，否则你会发现当你想修改一个逻辑时，你必须去修改多个地方！</p>
<p><strong>糟糕的:</strong></p>
<pre><code class="php">function showDeveloperList(array $developers): void
{
    foreach ($developers as $developer) {
        $expectedSalary = $developer-&gt;calculateExpectedSalary();
        $experience = $developer-&gt;getExperience();
        $githubLink = $developer-&gt;getGithubLink();
        $data = [
            $expectedSalary,
            $experience,
            $githubLink
        ];

        render($data);
    }
}

function showManagerList(array $managers): void
{
    foreach ($managers as $manager) {
        $expectedSalary = $manager-&gt;calculateExpectedSalary();
        $experience = $manager-&gt;getExperience();
        $githubLink = $manager-&gt;getGithubLink();
        $data = [
            $expectedSalary,
            $experience,
            $githubLink
        ];

        render($data);
    }
}</code></pre>
<p><strong>好的:</strong></p>
<pre><code class="php">function showList(array $employees): void
{
    foreach ($employees as $employee) {
        $expectedSalary = $employee-&gt;calculateExpectedSalary();
        $experience = $employee-&gt;getExperience();
        $githubLink = $employee-&gt;getGithubLink();
        $data = [
            $expectedSalary,
            $experience,
            $githubLink
        ];

        render($data);
    }
}</code></pre>
<p><strong>非常好:</strong></p>
<p>最好让你的代码紧凑一点。</p>
<pre><code class="php">function showList(array $employees): void
{
    foreach ($employees as $employee) {
        render([
            $employee-&gt;calculateExpectedSalary(),
            $employee-&gt;getExperience(),
            $employee-&gt;getGithubLink()
        ]);
    }
}</code></pre>

      
       <hr><span style="font-style: italic;color: gray;"> 欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 ljheiseberg@163.com </span>
    </div>
</article>



<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>PHP 代码简洁之道</p>
    <p><span class="copy-title">文章字数:</span><span class="post-count">7.2k</span></p>
    <p><span class="copy-title">本文作者:</span><a  title="LJHeisenberg">LJHeisenberg</a></p>
    <p><span class="copy-title">发布时间:</span>2019-12-25, 10:40:44</p>
    <p><span class="copy-title">最后更新:</span>2019-12-25, 10:45:56</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2019/12/25/php-code-clean/" title="PHP 代码简洁之道">https://ljheisenberg1072.github.io/2019/12/25/php-code-clean/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
    </p>
</div>



    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: '2b2331874cb6b5597b3f',
            clientSecret: 'e4059cb803e897010ba496877419a92425043522',
            repo: 'ljheisenberg1072.github.io',
            owner: 'ljheisenberg1072',
            admin: ['ljheisenberg1072'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">©2019-2020 LJHeisenberg</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket" ></a>

    </div>
</div>
<div class="acParent"></div>

</body>
<script src="/js/jquery.pjax.js?v=1.0.1" ></script>

<script src="/js/script.js?v=1.0.1" ></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#部署','#评论','#会员','#Clean',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $(".post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().split('\n').length - 1, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0px;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
        .nav .hide-list.fullscreen {
            left: 492px
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        background: url("https://i.loli.net/2019/07/22/5d3521411f3f169375.png");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
</style>







</html>
