<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LJHeisenberg&#39; Blog</title>
  
  <subtitle>ljheisenberg</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ljheisenberg1072.github.io/"/>
  <updated>2021-04-27T03:32:14.899Z</updated>
  <id>https://ljheisenberg1072.github.io/</id>
  
  <author>
    <name>LJHeisenberg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何避免重复下订单</title>
    <link href="https://ljheisenberg1072.github.io/2021/03/14/how-to-avoid-create-repeat-order/"/>
    <id>https://ljheisenberg1072.github.io/2021/03/14/how-to-avoid-create-repeat-order/</id>
    <published>2021-03-14T11:20:20.000Z</published>
    <updated>2021-04-27T03:32:14.899Z</updated>
    
    <content type="html"><![CDATA[<p>电子交易的一个很基本的问题，就是避免用户下重复订单。用户明明想买一次，结果一看下了两个单。如果没有及时发现，就会带来额外的物流成本和扯皮。对商家的信誉也不好看。</p><p>从技术上看，这是一个分布式一致性问题；但实际上，技术无法100%解决这类问题，得结合多种手段综合处理。这里就来说道说道。</p><h2 id="为啥会下重了呢？"><a href="#为啥会下重了呢？" class="headerlink" title="为啥会下重了呢？"></a>为啥会下重了呢？</h2><h3 id="原因1：客户端bug"><a href="#原因1：客户端bug" class="headerlink" title="原因1：客户端bug"></a>原因1：客户端bug</h3><p>比如下单的按键在点按之后，在没有收到服务器请求之前，按键的状态没有设为已禁用状态，还可以被按。又或者，在触摸屏下，用户手指的点按可能被手机操作系统识别为多次点击。</p><p>嗯，谁能保证客户端不偶尔出个什么bug 呢。</p><h3 id="原因2-超时"><a href="#原因2-超时" class="headerlink" title="原因2: 超时"></a>原因2: 超时</h3><p>用户的设备与服务器之间可能是不稳定的网路。这样一个下单请求过去，返回不一定回得来。超时最大的问题是: 从用户的角度，他无法确定下单的请求是还没到服务器，还是已经到了服务器但是返回丢失了。——用户无法区分到底这个单下了还是没下。</p><p>这样在等待一个超时后，UI可能会提示用户下单超时，请重复再试。</p><p><img src="/images/repeat-order/pic_001.jpg" alt="下单超时"></p><h3 id="原因3-用户的App闪退-人工强退，之后重新打开重新下单"><a href="#原因3-用户的App闪退-人工强退，之后重新打开重新下单" class="headerlink" title="原因3: 用户的App闪退/人工强退，之后重新打开重新下单"></a>原因3: 用户的App闪退/人工强退，之后重新打开重新下单</h3><p>也许可以使用一些技术手段避免用户下重单，但是心急的用户可能会重启流程/重启App/重启手机。在这种强制的手段下，任何技术手段都会失效——用户压根就不让你的技术执行，你怎么玩？</p><p>在这些条件下，如何避免用户多下了一笔订单呢？</p><h2 id="用幂等防止重复订单"><a href="#用幂等防止重复订单" class="headerlink" title="用幂等防止重复订单"></a>用幂等防止重复订单</h2><p>在技术方面，这是一个分布式一致性的问题，即客户端和服务器端对某个订单是否成功/失败达成一致。防止重单的关键是使用一个由客户端生成的，可用于避免重复的key，俗称dedup key（deduplicate key之意）。这个key可以用任意可以保证全局唯一性的方式生成，比如uuid。客户端和服务器需要使用这个dedup key作为串联条件，一起解决去重问题。</p><h2 id="客户端的流程"><a href="#客户端的流程" class="headerlink" title="客户端的流程"></a>客户端的流程</h2><p>客户端需要实现这样一个下单界面。用户点击【确认下单】时，应该产生一个独一无二的<code>dedup key</code>，连定订单数据发送给服务器端。在服务器返回之前，该界面应该一直等待，直到服务器响应成功/失败或者超时发生（比如15秒后，收不到服务器响应）。如果超时发生，应该向用户提示是否重试下单或者退出该界面。当用户点击【重试】时，应该用刚刚生成的<code>dedup key</code>来再次发送下单请求——如果用户一直不退出这个流程，每次用户点击重试，都应该用这个<code>dedup key</code>来重试下单，直到服务器正常返回，或者用户放弃返回。</p><p><img src="/images/repeat-order/pic_002.jpg" alt="下单的客户端流程"></p><h2 id="后端数据表设计"><a href="#后端数据表设计" class="headerlink" title="后端数据表设计"></a>后端数据表设计</h2><p>后端在订单数据表中，需要增加<code>dedup_key</code>这列，并设置唯一约束。</p><pre><code class="sql">create table order(  # ...  dedup_key varchar(60) not null comment &#39;key to pretend order duplication&#39;,  # ...  unique uniq_dedup_key(dedup_key));</code></pre><h2 id="下单的实现"><a href="#下单的实现" class="headerlink" title="下单的实现"></a>下单的实现</h2><p>在实现下单逻辑时，基于该dedup_key实现一个”create-or-get”语义的下单接口——简单说就是</p><p>如果带有指定dedup_key的订单已经存在，则直接返回；否则，用该<code>dedup_key</code>下单。<br>用伪代码表示大概是：</p><pre><code class="php">@TransactionalOrder createOrder(Integer userId, String prodCode, Decimal amount, String dedupKey) {  try {    String orderId = createOrder(userId, prodCode, amount, deupKey); // insert a new order    Order order = getOrderById(orderId); // read order from db    order.setDuplicated(false);    return order;  } catch(UniqueKeyViolationException e) {    // if duplicated order has existed    Order order = getOrderByDedupKey(dedupKey);    order.setDuplicated(true);    return order;  } catch (Exception e) {    // hanlde other errors and rollback transaction ...  }}</code></pre><p>这时，这段下单代码总是能返回一个订单（除非发生一些DB挂了之类的错误），要么是新创建的，要么就是一个已经存在的单。注意，最好在订单里增加一个属性（比如例子中用“duplicated”）来表示这个订单是这次新生成的，还是因为幂等而直接返回的。这样前端可以有针对性的对这两种情况提示不同的文案。</p><p>技术搞定幂等就足够了吗？<br>上面的流程没有考虑一种情况，就是用户中途强制退出客户端，或者直接点击【返回】回到产品页，重新走下单流程。这个时候客户端就无法判断用户到底是想重新下单，还是想第二次下单。此时，可以从产品设计上考虑一下。</p><p>比如，在客户端缓存一个表，记录所有没有确认结果的订单。</p><table><thead><tr><th align="right"></th><th align="center">产品代码</th><th align="center">产品数量</th><th align="center">金额</th><th align="left">dedup key</th></tr></thead><tbody><tr><td align="right">未确认订单1</td><td align="center">A</td><td align="center">1</td><td align="center">500</td><td align="left">xxx-yyy-zzz</td></tr><tr><td align="right">未确认订单2</td><td align="center">B</td><td align="center">2</td><td align="center">1000</td><td align="left">aaa-bbb-ccc</td></tr><tr><td align="right">…</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="left"></td></tr></tbody></table><p>通过这个表，我们可以猜一下用户的意图。比如，如果用户重新提交了一笔订单，其产品代码、金额与表中记录的某条完全一致，就可以提示一下用户:</p><p><img src="/images/repeat-order/pic_003.jpg" alt="提示一下用户是不是下重了"></p><p>如果用户想重试，可以继续用表中对应记录的dedup key重新发起下单。</p><p>这样不是绝对准确的，仅仅是尽量的减少用户误操作的可能性。当然，在产品设计上可以能出于用户交互简化，不一定真的会这样做。这就需要其他机制来配合，比如“通知”。</p><h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p>一旦服务器下单成功，可以通过某种通知机制（如APNS、Websocket）主动将订单推送至客户端，强行让客户端重新拉取最新的订单信息，并配合“未确认订单”表，以通知Badge/弹框等方式提示用户刚刚一笔状态未知的订单成功/失败了。</p><p>另外一种手段就是，服务器端实时扫描用户的下单数据，一旦发现可能的重单，就立刻通知客服主动联系用户，及时处理问题。</p><h2 id="如果还拦不住……"><a href="#如果还拦不住……" class="headerlink" title="如果还拦不住……"></a>如果还拦不住……</h2><p>经过层层阻拦，可能还是会有用户误操作，直到收到两份商品才发现下重了。此时就得依靠运营/客服的支持了。提供用户申诉的手段，让用户提出哪些订单是重复的，并且由销售系统店家、商品提供者和买家三方共同根据用户操作的记录来协商如何处理。我们需要让技术帮助让这种人工处理的几率尽量小。因为每次处理都会耗费较大的人工成本，和一些运营费用（比如赔款、小礼品等等）。</p><h2 id="这么麻烦，有必要吗？"><a href="#这么麻烦，有必要吗？" class="headerlink" title="这么麻烦，有必要吗？"></a>这么麻烦，有必要吗？</h2><p>这要分业务场景，对于很多电商来讲可能不是必要的。因为从用户下单到订单被审核处理进入到发货阶段需要一定的时间（可能是半小时～1小时），并且一定是支付成功后才会开始进行下一步流程。在这个时间段，用户大概率能从网络错误中恢复过来，自行区分是否下重了。配合客服主动提示，会极大的降低出问题的概率。</p><p>但是对于理财服务来说，这种去重就非常必要了。因为</p><p>“下单+支付”。用户购买理财往往是“下单+支付”一起执行，不可以单独下单/单独支付<br>用户的入金可能很大。例如数万，数十万<br>准确性丢失。如果一旦下重了，有可能影响用户的投资资金配置的准确性。<br>撤销难。部分理财产品存在下单不可撤销的问题；或者即便撤销，资金也无法立刻回款。等到回款，可能这个购入机会就错过去了。例如对于基金交易，错过1个交易日，价格就会发生变动。<br>基于这些特性，在理财产品中，就要竭尽全力的去重。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>以上所讲是处理重复订单问题的一般方法。你可以注意到，无论多么好的技术，也不可能100%的拦截所有的可能性，必须依靠技术+产品设计+运营支持的综合手段才能解决这类问题。</p><p>另外，本文还没涉及到关于订单支付（支付也可能重复哦）带来的进一步的复杂性，也没有讨论在高并发情况下的性能优化，仅仅讨论下单本身的问题。所以可以想象一下现实中的交易业务比这里的说的要复杂得多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;电子交易的一个很基本的问题，就是避免用户下重复订单。用户明明想买一次，结果一看下了两个单。如果没有及时发现，就会带来额外的物流成本和扯皮。对商家的信誉也不好看。&lt;/p&gt;
&lt;p&gt;从技术上看，这是一个分布式一致性问题；但实际上，技术无法100%解决这类问题，得结合多种手段综合处
      
    
    </summary>
    
    
      <category term="Order" scheme="https://ljheisenberg1072.github.io/categories/Order/"/>
    
    
      <category term="重复下单" scheme="https://ljheisenberg1072.github.io/tags/%E9%87%8D%E5%A4%8D%E4%B8%8B%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>实现接口幂等性的几种方案</title>
    <link href="https://ljheisenberg1072.github.io/2021/03/13/interface-idempotency/"/>
    <id>https://ljheisenberg1072.github.io/2021/03/13/interface-idempotency/</id>
    <published>2021-03-13T12:30:15.000Z</published>
    <updated>2021-04-27T02:55:18.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接口幂等性背景"><a href="#接口幂等性背景" class="headerlink" title="接口幂等性背景"></a>接口幂等性背景</h2><p>抢微信红包的时候我们都知道：一个红包一旦你抢过之后，以后无论你点多少次都是一样的结果。红包会提示你已经抢过此红包，而不会让你再抢一次。</p><p>抢红包接口就是一个非常典型的幂等接口，抢一次和抢多次具有一样的效果。类似的接口在我们的开发过程中会有很多，比如在电商的下单过程中：</p><p>订单创建接口,第一次调用返回超时了，重试机制一般会再次调用这个接口，此时我们不能因为这个接口被调了两次就创建两个一样的订单；<br>库存扣减接口，支付接口也是类似的逻辑；</p><h2 id="什么是幂等"><a href="#什么是幂等" class="headerlink" title="什么是幂等"></a>什么是幂等</h2><p>幂等原先是数学中的一个概念，表示进行1次变换和进行N次变换产生的效果相同。</p><p>当我们讨论接口的幂等性时一般是在说：以相同的请求调用这个接口一次和调用这个接口多次，对系统产生的影响是相同的。如果一个接口满足这个特性，那么我们就说这个<br>接口是一个幂等接口。比如上面的抢红包接口。</p><blockquote><p>PS：这边顺带说下幂等和防止重复提交的区别。<br>防止重复提交更多的是不让用户发起多次一样的请求。比如说用户在线购物下单时点了提交订单按钮，但是由于网络原因响应很慢，此时用户比较心急多次点击了订单提交按钮。<br>这种情况下就可能会造成多次下单。一般防止重复提交的方案有：将订单按钮置灰，跳转到结果页等。主要还是从客户端的角度来解决这个问题。</p></blockquote><blockquote><p>幂等更多的是在重复请求已经发生，或是无法避免的情况下，采取一定的技术手段让这些重复请求不给系统带来副作用。</p></blockquote><h2 id="什么情况下需要幂等"><a href="#什么情况下需要幂等" class="headerlink" title="什么情况下需要幂等"></a>什么情况下需要幂等</h2><p>并不是所有接口都需要保证幂等性。以相同的请求调用这个接口一次或多次，需要给调用方返回一致的结果时，就要考虑将这个接口设计成幂等接口。</p><h3 id="实现幂等的几种方案"><a href="#实现幂等的几种方案" class="headerlink" title="实现幂等的几种方案"></a>实现幂等的几种方案</h3><p>在我们设计幂等接口时重点关注新增接口和更新接口。因为查询和删除操作天生是幂等的（根据id查询和根据id删除多次对系统的影响是一致的），不需要我们提供额外的<br>技术手段来保证幂等性。</p><p>对于新增和更新接口，大致有以下几种方案可以保证接口幂等性。</p><h4 id="来源加序列号"><a href="#来源加序列号" class="headerlink" title="来源加序列号"></a>来源加序列号</h4><p>这是一种比较好理解，通用的方案。</p><p>当调用接口时，参数中必须传入source字段和seq字段（这边举了一个我们项目中的列子，其实并不一定要传两个字段，传一个唯一的序列号uuid也能达到一样的效果）。服务端接收到请求，先判断自己是否是一个幂等接口，如果不是幂等接口就正常处理请求。</p><p>如果是一个幂等接口，就将source和seq组成联合主键去数据库表中或者是Redis中查询，如果没有查询到，说明没处理过这个请求，然后正常处理请求就行了。处理完之后将处理结果和source和seq信息一个存入数据库或Redis中。</p><p>如果根据source和seq能查询到，说明已经处理过这个请求了，直接将处理的结果返回即可。</p><p>我们发现这种方案非常简单，而且易于理解，通用。但是如果请求量很大的话，存放请求记录的表会很大，这个时候可以将一段时间之前的记录删除，以提升性能。</p><h4 id="唯一索引（唯一字段）"><a href="#唯一索引（唯一字段）" class="headerlink" title="唯一索引（唯一字段）"></a>唯一索引（唯一字段）</h4><p>这种方案适合用于执行新增操作的接口。</p><p>比如说新增用户接口。我们将用户表中的身份证字段加上唯一索引。当同一个请求调用两次时，我们可以先根据身份证字段查询下用户是否存在，不存在的话再新增。存在的话就返回新增失败。<br>或者直接新增也行，数据库会抛异常，我们对异常处理返回前台就行了。</p><p>PS：大家可能会有一个疑问，我同一个请求调用两次，第一返回新增成功，第二次返回失败，返回的结果不同啊。这个接口还是幂等接口么？<br>这边我要重申下概念，幂等强调的是接口一次调用和多次调用产生的效果是一样的。这边调用一次和调用多次都是新增了一个对象，所以还是满足幂等的。</p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>这种方案适用于执行更新操作的接口。</p><p>乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。 我们一般通过数据库来实现乐观锁，比较通用的做法是增加一个时间戳字段。</p><pre><code class="sql">update table_xxx set name=#name#, timestamp = now where id=#id# and timestamp=#timestamp# --这个值由前端到数据中查询出来，再传过来</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;接口幂等性背景&quot;&gt;&lt;a href=&quot;#接口幂等性背景&quot; class=&quot;headerlink&quot; title=&quot;接口幂等性背景&quot;&gt;&lt;/a&gt;接口幂等性背景&lt;/h2&gt;&lt;p&gt;抢微信红包的时候我们都知道：一个红包一旦你抢过之后，以后无论你点多少次都是一样的结果。红包会提示你已
      
    
    </summary>
    
    
      <category term="Interface" scheme="https://ljheisenberg1072.github.io/categories/Interface/"/>
    
    
      <category term="幂等性" scheme="https://ljheisenberg1072.github.io/tags/%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>会员积分体系设计</title>
    <link href="https://ljheisenberg1072.github.io/2021/02/28/design-of-membership-points-system/"/>
    <id>https://ljheisenberg1072.github.io/2021/02/28/design-of-membership-points-system/</id>
    <published>2021-02-27T16:54:44.000Z</published>
    <updated>2021-04-27T02:55:27.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>积分体系是对用户行为的一种反馈，本质是用户忠诚度计划的一部分。能够一定层面上解决用户的 “促活、留存” 问题。当然，最重要的还是看公司有多少资源投入。下面讲下如何设计一个比较基础的通用会员积分体系。</p><h2 id="需求场景分析"><a href="#需求场景分析" class="headerlink" title="需求场景分析"></a>需求场景分析</h2><ol><li>是否对所有用户（新用户和老用户）？</li><li>积分的使用。可否当现金？兑换商品？</li><li>荣誉徽章制度？</li><li>如何获得积分？<br>……</li></ol><p>我们可以设计出以下基础表。</p><ol><li>用户积分账户（不考虑在原有的用户增加字段，而设计新表。是因为这是一个比较独立的系统。后期可能会加一些其他需求）</li><li>积分记录表（记录用户积分变动流水）</li><li>用户签到表</li><li>奖品（商品）表</li><li>兑换 (购买) 订单表</li><li>任务表</li><li>完成任务记录表</li></ol><p>用户积分表,上一篇的用户钱包表有做sign验证，这里就不验证了。因为积分相对于金钱来说，安全要求没那么高。</p><pre><code class="sql">CREATE TABLE `user_score` (  `user_uuid` char(32) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39; COMMENT &#39;用户id&#39;,  `level` tinyint(3) NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;等级&#39;,  `total_score` int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;总积分&#39;,  `usable_score` int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;可用积分&#39;,  `create_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,  `update_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,  `deleted` tinyint(1) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;是否删除&#39;,  PRIMARY KEY (`user_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC COMMENT=&#39;用户积分账户表&#39;</code></pre><p>记录积分流水信息。这里可以用一个字段的正负值来表示获得和使用积分。也可以用一个类型字段表示获得和支出</p><pre><code class="sql">CREATE TABLE `score_record` (  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;auto id&#39;,  `user_uuid` char(32) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39; COMMENT &#39;用户id&#39;,  `source_id` int(11) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39; COMMENT &#39;来源id&#39;,  `source_type` tinyint(1) NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;1 任务 2 系统赠送 3 取消订单 4 签到 5 兑换奖品 6过期&#39;,   `exprie_status` tinyint(1) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;是否过期0 没过期 1 过期&#39;,  `remark` varchar(64) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39; COMMENT &#39;备注&#39;,  `symbol` varchar(3) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39; COMMENT &#39;in 收入 out 支出&#39;,  `score` int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;分值&#39;,   `expire_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;过期时间&#39;,  `create_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,  PRIMARY KEY (`id`),  KEY `UCID` (`user_uuid`,`create_at`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC COMMENT=&#39;积分记录表&#39;</code></pre><p>前端纪录表。</p><pre><code class="sql">CREATE TABLE `user_sign_in` (  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;auto id&#39;,  `user_uuid` char(32) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39; COMMENT &#39;用户id&#39;,  `continue_day` smallint(6) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;持续签到天数&#39;,  `period_day` tinyint(3) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;周期内签到天数&#39;,  `create_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,  PRIMARY KEY (`id`),  KEY `UCID` (`user_uuid`,`create_at`),  KEY `create_at` (`create_at`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC COMMENT=&#39;用户签到表&#39;</code></pre><p>奖品表。</p><pre><code class="sql">CREATE TABLE `prize` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;auto id&#39;,  `score` int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;所需积分&#39;,  `stock` int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;库存&#39;,  `name` char(32) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39; COMMENT &#39;名称&#39;,  `img_url` varchar(255) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39; COMMENT &#39;图片url&#39;,  `introduction` varchar(255) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39; COMMENT &#39;简介&#39;,  `content` text COLLATE utf8mb4_general_ci NOT NULL COMMENT &#39;内容&#39;,  `status` tinyint(1) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;状态 0 草稿 1 发布 2  停用&#39;,  `sort` int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;排序&#39;,  `action_user` varchar(32) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39; COMMENT &#39;操作人&#39;,  `create_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,  `update_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,  `deleted` tinyint(1) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;是否删除&#39;,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC COMMENT=&#39;奖品表&#39;</code></pre><p>奖品订单表。这里的状态值。可以按系统其它表中的设计。</p><pre><code class="sql">CREATE TABLE `prize_order` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;auto id&#39;,  `user_uuid` char(32) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39; COMMENT &#39;用户id&#39;,   `prize_id` int(11) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;奖品id&#39;,  `deduct_score` int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;扣除积分&#39;,  `status` tinyint(1) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;0 待审核 1 经审核 2 不通过，3取消&#39;,  `audit_at` datetime DEFAULT NULL COMMENT &#39;审核时间&#39;,  `remark` varchar(255) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39; COMMENT &#39;备注&#39;,  `action_user` varchar(32) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39; COMMENT &#39;操作人&#39;,  `create_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,  `update_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,  `deleted` tinyint(1) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;是否删除&#39;,  PRIMARY KEY (`id`),  KEY `user_uuid` (`user_uuid`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC COMMENT=&#39;奖品兑换订单表&#39;</code></pre><p>获取积分的方式有很多种。所以增加了一张任务表，</p><pre><code class="sql">CREATE TABLE `task` (  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;auto id&#39;,  `name` varchar(32) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39; COMMENT &#39;简体名称&#39;,  `score` int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;分值&#39;,  `status` tinyint(1) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;状态 0 草稿 1 发布 2 停用&#39;,  `sort` int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;排序&#39;,  `is_pro` tinyint(1) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;1 pro专属&#39;,  `is_once` tinyint(1) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;1 一次性任务&#39;,  `link_params` varchar(255) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39; COMMENT &#39;任务链接参数&#39;,  `page_url` varchar(64) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39; COMMENT &#39;页面&#39;,  `thumb_url` varchar(255) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39; COMMENT &#39;图标&#39;,  `identify` varchar(32) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39; COMMENT &#39;标识符&#39;,  `remark` varchar(255) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39; COMMENT &#39;备注&#39;,  `action_user` varchar(32) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39; COMMENT &#39;操作人&#39;,  `create_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,  `update_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,  `deleted` tinyint(1) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;是否删除&#39;,  PRIMARY KEY (`id`),  KEY `identify` (`identify`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC COMMENT=&#39;任务表&#39;</code></pre><p>任务完成表</p><pre><code class="sql">CREATE TABLE `task_finish` (  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;auto id&#39;,  `user_uuid` char(32) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39; COMMENT &#39;用户id&#39;,  `task_id` int(11) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;任务Id&#39;,  `score_uuid` int(11) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;积分记录id&#39;,  `finish_score` int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;完成获得积分&#39;,  `create_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,  PRIMARY KEY (`id`),  KEY `UCID` (`user_uuid`,`create_at`),  KEY `UTCID` (`user_uuid`,`task_id`,`create_at`),  KEY `create_at` (`create_at`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC COMMENT=&#39;完成记录表&#39;</code></pre><p>以上表就是基础表了。可以根据自己的业务特点增删一些字段，或增加一些其它表</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>用户等级积分关系通常不会改变，因此这里就不放在数据库中了。直接写在 php 文件里</p><pre><code class="php">//等级与积分映射。可根据实际情况填写public $levelScoreMap = [  &#39;1&#39; =&gt; 0,  &#39;2&#39; =&gt; 100,  &#39;3&#39; =&gt; 300,  &#39;4&#39; =&gt; 400,  &#39;5&#39; =&gt; 500,  &#39;6&#39; =&gt; 750,  &#39;7&#39; =&gt; 1200,  &#39;8&#39; =&gt; 1800,  &#39;9&#39; =&gt; 2500,  &#39;10&#39; =&gt; 3500,  &#39;11&#39; =&gt; 5000,  &#39;12&#39; =&gt; 8000,  &#39;13&#39; =&gt; 15000,  &#39;14&#39; =&gt; 20000,  &#39;15&#39; =&gt; 30000,  &#39;16&#39; =&gt; 45000,];//七天连续签到天数与获得积分映射。可根据实际情况填写public $signInScoreMap = [    &#39;1&#39; =&gt; 5,    &#39;2&#39; =&gt; 5,    &#39;3&#39; =&gt; 5,    &#39;4&#39; =&gt; 15,    &#39;5&#39; =&gt; 5,    &#39;6&#39; =&gt; 5,    &#39;7&#39; =&gt; 30,];/**根据用户的积分获取用户等级 * @param $levelScoreMap * @param $levelArray * @param $totalScore * @return int */public function getLevel($totalScore){  $levelScore = $this-&gt;levelScoreMap;  krsort($levelScore);  foreach ($levelScore as $level =&gt; $score) {    if ($totalScore &gt;= $score) {        return $level;    }  }}</code></pre><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li><p>任务系统和积分系统最好拆分开来。<br>这么做的原因有几个，一来是因为，任务系统和积分系统未必属于同一个业务层，比如，任务系统的支持很可能是别的更偏向 C 端的团队在做，而积分系统更加偏向基础功能团队在做。即使是小项目，也最好分开来，毕竟积分的来源可能不止签到，还有可能是别的什么任务，签到后期的奖励也可能从积分改成其他。二是任务系统积分系统向来是用户和喜欢薅羊毛的地方，高峰期的服务器压力会比较大，处理任务和积分的逻辑太复杂的话会严重影响用户体验甚至宕机，所以我个人是比较推荐业务上拆开来的做法，任务系统单独处理逻辑，处理完成后塞一个消息进 MQ/Redis，其他系统以异步队列的方式去消费队列，处理发放积分或者其他额外的操作的逻辑。</p></li><li><p>并发问题。<br>这个问题应该是很多场景下要考虑的问题。有加积分就有消耗积分，要是这两个动作同时了怎么办？如果羊毛党水平比较高抓到了签到、任务的接口直接调接口一下子发送多个请求怎么办？这自然是要加分布式锁了，当然这也是个学问，锁的粒度上我们也吃过亏，任务上要加锁，积分上也是要加锁的，数据库上顺便也来个乐观锁吧。。。这个就看具体的业务需求上各自大显神通的，不过这个大体上的思路应该是没啥问题的。</p></li><li><p>对账问题。<br>这个问题是基于第一个问题产生的，系统间服务调用的一个基本原则就是互不信任，任务系统和积分系统拆分后，如何保证任务系统期望发放的积分跟积分中心实际发放的积分是一致的呢？如果说这中间任意一个系统出问题了怎么办？那就对账吧，明细账得对，总账也得对，对账的周期可以安排每天对一次明细，每月对一次总账。也是看具体业务需求而定了，实现上也很灵活，我们之前的方式是每天生成前一天的明细 CSV 文件，rsync 到积分系统的机器上，由积分系统对账并发送邮件报告对账结果，对账出问题了基本上是很高级别的故障等级了，双方基本上都是要第一时间找原因并修复的，补发或者扣除用户的积分。</p></li><li><p>反作弊问题。<br>积分是薅羊毛重灾区大家应该都有所耳闻，那反作弊自然也是要的，提高任务和积分的门槛，让普通用户能够正常收益而屏蔽掉作弊账号。这一点一般的小公司就比较不太好做了，一来技术上没有接触过自然是没有思路，二来也没有足够的人力物力来维护一个这样的系统。</p></li><li><p>由具体业务引出的其他问题。<br>比如：一个电商项目里如果积分可以用来抵扣订单的一部分费用，但是用户没有提交订单的时候这部分订单不算被消费，那么 “锁定 / 冻结积分” 这个操作应该怎么实现呢？如果需要实现积分的部分过期又怎么实现呢？如果在积分部分过期的基础上用户退款的积分需要返还这又怎么实现呢？</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;积分体系是对用户行为的一种反馈，本质是用户忠诚度计划的一部分。能够一定层面上解决用户的 “促活、留存” 问题。当然，最重要的还是看公司有多少
      
    
    </summary>
    
    
      <category term="Member" scheme="https://ljheisenberg1072.github.io/categories/Member/"/>
    
    
      <category term="会员" scheme="https://ljheisenberg1072.github.io/tags/%E4%BC%9A%E5%91%98/"/>
    
  </entry>
  
  <entry>
    <title>Laravel嵌套评论的实现</title>
    <link href="https://ljheisenberg1072.github.io/2021/02/27/laravel-nested-comment-realization/"/>
    <id>https://ljheisenberg1072.github.io/2021/02/27/laravel-nested-comment-realization/</id>
    <published>2021-02-27T12:30:44.000Z</published>
    <updated>2021-04-27T02:55:37.292Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>经常我们看见评论显示形式有很多，比如 ‘@’ 某某，又或者像知乎的收缩式的评论，又或者是嵌套式的评论，那么最一开始也是最常见的就是嵌套式评论，因为这个更加醒目.</p></blockquote><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>设计三张表 users,posts,comments，表结构如下:</li></ol><p>users</p><pre><code class="php">Schema::create(&#39;users&#39;, function (Blueprint $table) {    $table-&gt;increments(&#39;id&#39;);    $table-&gt;string(&#39;name&#39;);    $table-&gt;string(&#39;email&#39;)-&gt;unique();    $table-&gt;string(&#39;password&#39;);    $table-&gt;rememberToken();    $table-&gt;timestamps();});</code></pre><p>posts</p><pre><code class="php">Schema::create(&#39;posts&#39;, function (Blueprint $table) {    $table-&gt;increments(&#39;id&#39;);    $table-&gt;string(&#39;title&#39;);    $table-&gt;integer(&#39;user_id&#39;)-&gt;index();    $table-&gt;text(&#39;content&#39;);    $table-&gt;timestamps();});</code></pre><p>comments</p><p>其中 <code>parent_id</code> 主要表示该评论所属评论的 id, 如果不属于任何评论则为 null</p><pre><code class="php">Schema::create(&#39;comments&#39;, function (Blueprint $table) {      $table-&gt;increments(&#39;id&#39;);      $table-&gt;integer(&#39;user_id&#39;)-&gt;index();      $table-&gt;integer(&#39;post_id&#39;)-&gt;index();      $table-&gt;integer(&#39;parent_id&#39;)-&gt;index()-&gt;nullable();      $table-&gt;text(&#39;body&#39;);      $table-&gt;timestamps();  });</code></pre><ol start="2"><li>表之间的关系如下</li></ol><p>Post.php 文件</p><pre><code class="php">/**  * 一篇文章有多个评论  * @return \Illuminate\Database\Eloquent\Relations\HasMany  */public function comments(){    return $this-&gt;hasMany(Comment::class);}/**  * 获取这篇文章的评论以parent_id来分组  * @return static  */public function getComments(){    return $this-&gt;comments()-&gt;with(&#39;owner&#39;)-&gt;get()-&gt;groupBy(&#39;parent_id&#39;);}</code></pre><p>Comments.php 文件</p><pre><code class="php">/**  * 这个评论的所属用户  * @return \Illuminate\Database\Eloquent\Relations\BelongsTo  */public function owner(){    return $this-&gt;belongsTo(User::class, &#39;user_id&#39;);}/**  * 这个评论的子评论  * @return \Illuminate\Database\Eloquent\Relations\HasMany  */public function replies(){    return $this-&gt;hasMany(Comment::class, &#39;parent_id&#39;);}</code></pre><h3 id="逻辑编写"><a href="#逻辑编写" class="headerlink" title="逻辑编写"></a>逻辑编写</h3><p>我们所要实现的嵌套评论其实在我们准备工作中已经 有点思路了，我们首先将一篇文章显示出来，同时利用文章与评论的一对多关系，进行显示所有的评论，但是我们的评论里面涉及到一个字段就是<code>parent_id</code>，这个字段其实非常的特殊，我们利用这个字段来进行分组，代码就是上面的<code>return $this-&gt;comments()-&gt;with(&#39;owner&#39;)-&gt;get()-&gt;groupBy(&#39;parent_id&#39;)</code>, 具体的过程如下:</p><p>web.php 文件</p><pre><code class="php">\Auth::loginUsingId(1); //用户id为1的登录//显示文章和相应的评论Route::get(&#39;/post/show/{post}&#39;, function (\App\Post $post) {    $post-&gt;load(&#39;comments.owner&#39;);    $comments = $post-&gt;getComments();    $comments[&#39;root&#39;] = $comments[&#39;&#39;];    unset($comments[&#39;&#39;]);    return view(&#39;posts.show&#39;, compact(&#39;post&#39;, &#39;comments&#39;));});//用户进行评论Route::post(&#39;post/{post}/comments&#39;, function (\App\Post $post) {    $post-&gt;comments()-&gt;create([        &#39;body&#39; =&gt; request(&#39;body&#39;),        &#39;user_id&#39; =&gt; \Auth::id(),        &#39;parent_id&#39; =&gt; request(&#39;parent_id&#39;, null),    ]);    return back();});</code></pre><h3 id="视图代码"><a href="#视图代码" class="headerlink" title="视图代码"></a>视图代码</h3><p>视图方面我们需要实现嵌套，那么随着用户互相评论的越来越多的话，那么嵌套的层级也就越多，所以说，我们这里需要使用各小技巧来显示整个评论，我们使用 <code>@include()</code> 函数来显示，那么我们试图的结构如下:</p><ul><li>comments<ul><li>comments.blade.php</li><li>form.blade.php</li><li>list.blade.php</li></ul></li><li>posts<ul><li>show.blade.php</li></ul></li></ul><p>代码如下:</p><p>show.blade.php</p><pre><code class="php">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;    &lt;link href=&quot;//cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot; style=&quot;margin-top: 100px&quot;&gt;    &lt;div class=&quot;col-md-10 col-md-offset-1&quot;&gt;        &lt;h2&gt;{{$post->title}}&lt;/h2&gt;        &lt;h4&gt;{{$post->content}}&lt;/h4&gt;        &lt;hr&gt;        @include(&#39;comments.list&#39;,[&#39;collections&#39;=&gt;$comments[&#39;root&#39;]])        &lt;h3&gt;留下您的评论&lt;/h3&gt;        @include(&#39;comments.form&#39;,[&#39;parentId&#39;=&gt;$post-&gt;id])    &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>comment.blade.php</p><pre><code class="php">&lt;div class=&quot;col-md-12&quot;&gt;    &lt;h5&gt;&lt;span style=&quot;color:#31b0d5&quot;&gt;{{$comment->owner->name}}&lt;/span&gt;:&lt;/h5&gt;    &lt;h5&gt;{{$comment->body}}&lt;/h5&gt;    @include(&#39;comments.form&#39;,[&#39;parentId&#39;=&gt;$comment-&gt;id])    @if(isset($comments[$comment-&gt;id]))        @include(&#39;comments.list&#39;,[&#39;collections&#39;=&gt;$comments[$comment-&gt;id]])    @endif    &lt;hr&gt;&lt;/div&gt;</code></pre><p>form.blade.php</p><pre><code class="php">&lt;form method=&quot;POST&quot; action=&quot;{{url('post/'.$post->id.'/comments')}}&quot; accept-charset=&quot;UTF-8&quot;&gt;    {{csrf_field()}}    @if(isset($parentId))        &lt;input type=&quot;hidden&quot; name=&quot;parent_id&quot; value=&quot;{{$parentId}}&quot;&gt;    @endif    &lt;div class=&quot;form-group&quot;&gt;        &lt;label for=&quot;body&quot; class=&quot;control-label&quot;&gt;Info:&lt;/label&gt;        &lt;textarea id=&quot;body&quot; name=&quot;body&quot;  class=&quot;form-control&quot; required=&quot;required&quot;&gt;&lt;/textarea&gt;    &lt;/div&gt;    &lt;button type=&quot;submit&quot; class=&quot;btn btn-success&quot;&gt;回复&lt;/button&gt;&lt;/form&gt;</code></pre><p>list.blade.php</p><pre><code class="php">@foreach($collections as $comment)    @include(&#39;comments.comment&#39;,[&#39;comment&#39;=&gt;$comment])@endforeach</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;经常我们看见评论显示形式有很多，比如 ‘@’ 某某，又或者像知乎的收缩式的评论，又或者是嵌套式的评论，那么最一开始也是最常见的就是嵌套式评论，因为这个更加醒目.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准
      
    
    </summary>
    
    
      <category term="Comment" scheme="https://ljheisenberg1072.github.io/categories/Comment/"/>
    
    
      <category term="评论" scheme="https://ljheisenberg1072.github.io/tags/%E8%AF%84%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>PHP 代码简洁之道</title>
    <link href="https://ljheisenberg1072.github.io/2019/12/25/php-code-clean/"/>
    <id>https://ljheisenberg1072.github.io/2019/12/25/php-code-clean/</id>
    <published>2019-12-25T02:40:44.000Z</published>
    <updated>2021-04-27T02:55:42.834Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PHP-代码简洁之道"><a href="#PHP-代码简洁之道" class="headerlink" title="PHP 代码简洁之道"></a>PHP 代码简洁之道</h2><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Robert C.Martin’s 的 软件工程师准则 <a href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882" target="_blank" rel="noopener"><em>Clean Code</em></a> 同样适用于 PHP。它并不是一个编码风格指南，它指导我们用 PHP 写出具有可读性，可复用性且可分解的代码。</p><p>并非所有的准则都必须严格遵守，甚至一些已经成为普遍的约定。这仅仅作为指导方针，其中许多都是 <em>Clean Code</em> 作者们多年来的经验。</p><blockquote><p>灵感来自于 <a href="https://github.com/ryanmcdermott/clean-code-javascript" target="_blank" rel="noopener">clean-code-javascript</a></p></blockquote><p>尽管许多开发者依旧使用 PHP 5 版本，但是这篇文章中绝大多数例子都是只能在 PHP 7.1 + 版本下运行。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="使用有意义的且可读的变量名"><a href="#使用有意义的且可读的变量名" class="headerlink" title="使用有意义的且可读的变量名"></a>使用有意义的且可读的变量名</h3><p><strong>不友好的：</strong></p><pre><code class="php">$ymdstr = $moment-&gt;format(&#39;y-m-d&#39;);</code></pre><p><strong>友好的：</strong></p><pre><code class="php">$currentDate = $moment-&gt;format(&#39;y-m-d&#39;);</code></pre><h3 id="对同类型的变量使用相同的词汇"><a href="#对同类型的变量使用相同的词汇" class="headerlink" title="对同类型的变量使用相同的词汇"></a>对同类型的变量使用相同的词汇</h3><p><strong>不友好的：</strong></p><pre><code class="php">getUserInfo();getUserData();getUserRecord();getUserProfile();</code></pre><p><strong>友好的：</strong></p><pre><code class="php">getUser();</code></pre><h3 id="使用可搜索的名称（第一部分）"><a href="#使用可搜索的名称（第一部分）" class="headerlink" title="使用可搜索的名称（第一部分）"></a>使用可搜索的名称（第一部分）</h3><p>我们阅读的代码超过我们写的代码。所以我们写出的代码需要具备可读性、可搜索性，这一点非常重要。要我们去理解程序中没有名字的变量是非常头疼的。让你的变量可搜索吧！</p><p><strong>不具备可读性的代码：</strong></p><pre><code class="php">//  见鬼的 448 是什么意思？$result = $serializer-&gt;serialize($data, 448);</code></pre><p><strong>具备可读性的：</strong></p><pre><code class="php">$json = $serializer-&gt;serialize($data, JSON_UNESCAPED_SLASHES | JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE);</code></pre><h3 id="使用可搜索的名称（第二部分）"><a href="#使用可搜索的名称（第二部分）" class="headerlink" title="使用可搜索的名称（第二部分）"></a>使用可搜索的名称（第二部分）</h3><p><strong>不好的：</strong></p><pre><code class="php">// 见鬼的 4 又是什么意思？if ($user-&gt;access &amp; 4) {    // ...}</code></pre><p><strong>好的方式：</strong></p><pre><code class="php">class User{    const ACCESS_READ = 1;    const ACCESS_CREATE = 2;    const ACCESS_UPDATE = 4;    const ACCESS_DELETE = 8;}if ($user-&gt;access &amp; User::ACCESS_UPDATE) {    // do edit ...}</code></pre><h3 id="使用解释性变量"><a href="#使用解释性变量" class="headerlink" title="使用解释性变量"></a>使用解释性变量</h3><p><strong>不好：</strong></p><pre><code class="php">$address = &#39;One Infinite Loop, Cupertino 95014&#39;;$cityZipCodeRegex = &#39;/^[^,]+,\s*(.+?)\s*(\d{5})$/&#39;;preg_match($cityZipCodeRegex, $address, $matches);saveCityZipCode($matches[1], $matches[2]);</code></pre><p><strong>一般：</strong></p><p>这个好点，但我们仍严重依赖正则表达式。</p><pre><code class="php">$address = &#39;One Infinite Loop, Cupertino 95014&#39;;$cityZipCodeRegex = &#39;/^[^,]+,\s*(.+?)\s*(\d{5})$/&#39;;preg_match($cityZipCodeRegex, $address, $matches);[, $city, $zipCode] = $matches;saveCityZipCode($city, $zipCode);</code></pre><p><strong>很棒：</strong></p><p>通过命名子模式减少对正则表达式的依赖。</p><pre><code class="php">$address = &#39;One Infinite Loop, Cupertino 95014&#39;;$cityZipCodeRegex = &#39;/^[^,]+,\s*(?&lt;city&gt;.+?)\s*(?&lt;zipCode&gt;\d{5})$/&#39;;preg_match($cityZipCodeRegex, $address, $matches);saveCityZipCode($matches[&#39;city&#39;], $matches[&#39;zipCode&#39;]);</code></pre><h3 id="避免嵌套太深和提前返回-第一部分"><a href="#避免嵌套太深和提前返回-第一部分" class="headerlink" title="避免嵌套太深和提前返回 (第一部分)"></a>避免嵌套太深和提前返回 (第一部分)</h3><p>使用太多 <code>if else</code> 表达式会导致代码难以理解。<br>明确优于隐式。</p><p><strong>不好:</strong></p><pre><code class="php">function isShopOpen($day): bool{    if ($day) {        if (is_string($day)) {            $day = strtolower($day);            if ($day === &#39;friday&#39;) {                return true;            } elseif ($day === &#39;saturday&#39;) {                return true;            } elseif ($day === &#39;sunday&#39;) {                return true;            } else {                return false;            }        } else {            return false;        }    } else {        return false;    }}</code></pre><p><strong>很棒：</strong></p><pre><code class="php">function isShopOpen(string $day): bool{    if (empty($day)) {        return false;    }    $openingDays = [        &#39;friday&#39;, &#39;saturday&#39;, &#39;sunday&#39;    ];    return in_array(strtolower($day), $openingDays, true);}</code></pre><h3 id="避免嵌套太深和提前返回-第二部分"><a href="#避免嵌套太深和提前返回-第二部分" class="headerlink" title="避免嵌套太深和提前返回 (第二部分)"></a>避免嵌套太深和提前返回 (第二部分)</h3><p><strong>不好：</strong></p><pre><code class="php">function fibonacci(int $n){    if ($n &lt; 50) {        if ($n !== 0) {            if ($n !== 1) {                return fibonacci($n - 1) + fibonacci($n - 2);            } else {                return 1;            }        } else {            return 0;        }    } else {        return &#39;Not supported&#39;;    }}</code></pre><p><strong>很棒：</strong></p><pre><code class="php">function fibonacci(int $n): int{    if ($n === 0 || $n === 1) {        return $n;    }    if ($n &gt; 50) {        throw new \Exception(&#39;Not supported&#39;);    }    return fibonacci($n - 1) + fibonacci($n - 2);}</code></pre><h3 id="避免心理映射"><a href="#避免心理映射" class="headerlink" title="避免心理映射"></a>避免心理映射</h3><p>不要迫使你的代码阅读者翻译变量的意义。<br>明确优于隐式。</p><p><strong>不好：</strong></p><pre><code class="php">$l = [&#39;Austin&#39;, &#39;New York&#39;, &#39;San Francisco&#39;];for ($i = 0; $i &lt; count($l); $i++) {    $li = $l[$i];    doStuff();    doSomeOtherStuff();    // ...    // ...    // ...    // Wait, what is `$li` for again?    dispatch($li);}</code></pre><p><strong>很棒：</strong></p><pre><code class="php">$locations = [&#39;Austin&#39;, &#39;New York&#39;, &#39;San Francisco&#39;];foreach ($locations as $location) {    doStuff();    doSomeOtherStuff();    // ...    // ...    // ...    dispatch($location);}</code></pre><h3 id="不要增加不需要的上下文"><a href="#不要增加不需要的上下文" class="headerlink" title="不要增加不需要的上下文"></a>不要增加不需要的上下文</h3><p>如果类名或对象名告诉你某些东西后，请不要在变量名中重复。</p><p><strong>小坏坏：</strong></p><pre><code class="php">class Car{    public $carMake;    public $carModel;    public $carColor;    //...}</code></pre><p><strong>好的方式：</strong></p><pre><code class="php">class Car{    public $make;    public $model;    public $color;    //...}</code></pre><h3 id="使用默认参数而不是使用短路运算或者是条件判断"><a href="#使用默认参数而不是使用短路运算或者是条件判断" class="headerlink" title="使用默认参数而不是使用短路运算或者是条件判断"></a>使用默认参数而不是使用短路运算或者是条件判断</h3><p><strong>不好的做法:</strong></p><p>这是不太好的因为 <code>$breweryName</code> 可以是 <code>NULL</code>.</p><pre><code class="php">function createMicrobrewery($breweryName = &#39;Hipster Brew Co.&#39;): void{    // ...}</code></pre><p><strong>还算可以的做法:</strong></p><p>这个做法比上面的更加容易理解，但是它需要很好的去控制变量的值.</p><pre><code class="php">function createMicrobrewery($name = null): void{    $breweryName = $name ?: &#39;Hipster Brew Co.&#39;;    // ...}</code></pre><p><strong>好的做法:</strong></p><p>你可以使用 <a href="http://php.net/manual/en/functions.arguments.php#functions.arguments.type-declaration" target="_blank" rel="noopener">类型提示</a> 而且可以保证 <code>$breweryName</code> 不会为空 <code>NULL</code>.</p><pre><code class="php">function createMicrobrewery(string $breweryName = &#39;Hipster Brew Co.&#39;): void{    // ...}</code></pre><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><h3 id="使用-相等运算符"><a href="#使用-相等运算符" class="headerlink" title="使用 相等运算符"></a>使用 <a href="http://php.net/manual/en/language.operators.comparison.php" target="_blank" rel="noopener">相等运算符</a></h3><p><strong>不好的做法:</strong></p><pre><code class="php">$a = &#39;42&#39;;$b = 42;使用简单的相等运算符会把字符串类型转换成数字类型if( $a != $b ) {   //这个条件表达式总是会通过}</code></pre><p>表达式 $a != $b 会返回 false 但实际上它应该是 true !<br>字符串类型 ‘42’ 是不同于数字类型的 42</p><p><strong>好的做法:</strong><br>使用全等运算符会对比类型和值</p><pre><code class="php">if( $a !== $b ) {    //这个条件是通过的}</code></pre><p>表达式 $a !== $b 会返回 true。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数参数（2-个或更少）"><a href="#函数参数（2-个或更少）" class="headerlink" title="函数参数（2 个或更少）"></a>函数参数（2 个或更少）</h3><p>限制函数参数个数极其重要<br>这样测试你的函数容易点。有超过 3 个可选参数会导致一个爆炸式组合增长，你会有成吨独立参数情形要测试。</p><p>无参数是理想情况。1 个或 2 个都可以，最好避免 3 个。<br>再多就需要加固了。通常如果你的函数有超过两个参数，说明他要处理的事太多了。 如果必须要传入很多数据，建议封装一个高级别对象作为参数。</p><p><strong>不友好的:</strong></p><pre><code class="php">function createMenu(string $title, string $body, string $buttonText, bool $cancellable): void{    // ...}</code></pre><p><strong>友好的:</strong></p><pre><code class="php">class MenuConfig{    public $title;    public $body;    public $buttonText;    public $cancellable = false;}$config = new MenuConfig();$config-&gt;title = &#39;Foo&#39;;$config-&gt;body = &#39;Bar&#39;;$config-&gt;buttonText = &#39;Baz&#39;;$config-&gt;cancellable = true;function createMenu(MenuConfig $config): void{    // ...}</code></pre><h3 id="函数应该只做一件事情"><a href="#函数应该只做一件事情" class="headerlink" title="函数应该只做一件事情"></a>函数应该只做一件事情</h3><p>这是迄今为止软件工程最重要的原则。函数做了超过一件事情时，它们将变得难以编写、测试、推导。 而函数只做一件事情时，重构起来则非常简单，同时代码阅读起来也非常清晰。掌握了这个原则，你就会领先许多其他的开发者。</p><p><strong>不好的:</strong></p><pre><code class="php">function emailClients(array $clients): void{    foreach ($clients as $client) {        $clientRecord = $db-&gt;find($client);        if ($clientRecord-&gt;isActive()) {            email($client);        }    }}</code></pre><p><strong>好的:</strong></p><pre><code class="php">function emailClients(array $clients): void{    $activeClients = activeClients($clients);    array_walk($activeClients, &#39;email&#39;);}function activeClients(array $clients): array{    return array_filter($clients, &#39;isClientActive&#39;);}function isClientActive(int $client): bool{    $clientRecord = $db-&gt;find($client);    return $clientRecord-&gt;isActive();}</code></pre><h3 id="函数的名称要说清楚它做什么"><a href="#函数的名称要说清楚它做什么" class="headerlink" title="函数的名称要说清楚它做什么"></a>函数的名称要说清楚它做什么</h3><p><strong>不好的例子:</strong></p><pre><code class="php">class Email{    //...    public function handle(): void    {        mail($this-&gt;to, $this-&gt;subject, $this-&gt;body);    }}$message = new Email(...);// What is this? A handle for the message? Are we writing to a file now?$message-&gt;handle();</code></pre><p><strong>很好的例子:</strong></p><pre><code class="php">class Email {    //...    public function send(): void    {        mail($this-&gt;to, $this-&gt;subject, $this-&gt;body);    }}$message = new Email(...);// Clear and obvious$message-&gt;send();</code></pre><h3 id="函数只能是一个抽象级别"><a href="#函数只能是一个抽象级别" class="headerlink" title="函数只能是一个抽象级别"></a>函数只能是一个抽象级别</h3><p>当你有多个抽象层次时，你的函数功能通常是做太多了。 分割函数功能使得重用性和测试更加容易。.</p><p><strong>不好:</strong></p><pre><code class="php">function parseBetterJSAlternative(string $code): void{    $regexes = [        // ...    ];    $statements = explode(&#39; &#39;, $code);    $tokens = [];    foreach ($regexes as $regex) {        foreach ($statements as $statement) {            // ...        }    }    $ast = [];    foreach ($tokens as $token) {        // lex...    }    foreach ($ast as $node) {        // parse...    }}</code></pre><p><strong>同样不是很好:</strong></p><p>我们已经完成了一些功能，但是 <code>parseBetterJSAlternative()</code> 功能仍然非常复杂，测试起来也比较麻烦。</p><pre><code class="php">function tokenize(string $code): array{    $regexes = [        // ...    ];    $statements = explode(&#39; &#39;, $code);    $tokens = [];    foreach ($regexes as $regex) {        foreach ($statements as $statement) {            $tokens[] = /* ... */;        }    }    return $tokens;}function lexer(array $tokens): array{    $ast = [];    foreach ($tokens as $token) {        $ast[] = /* ... */;    }    return $ast;}function parseBetterJSAlternative(string $code): void{    $tokens = tokenize($code);    $ast = lexer($tokens);    foreach ($ast as $node) {        // parse...    }}</code></pre><p><strong>很好的:</strong></p><p>最好的解决方案是取出 <code>parseBetterJSAlternative()</code> 函数的依赖关系.</p><pre><code class="php">class Tokenizer{    public function tokenize(string $code): array    {        $regexes = [            // ...        ];        $statements = explode(&#39; &#39;, $code);        $tokens = [];        foreach ($regexes as $regex) {            foreach ($statements as $statement) {                $tokens[] = /* ... */;            }        }        return $tokens;    }}class Lexer{    public function lexify(array $tokens): array    {        $ast = [];        foreach ($tokens as $token) {            $ast[] = /* ... */;        }        return $ast;    }}class BetterJSAlternative{    private $tokenizer;    private $lexer;    public function __construct(Tokenizer $tokenizer, Lexer $lexer)    {        $this-&gt;tokenizer = $tokenizer;        $this-&gt;lexer = $lexer;    }    public function parse(string $code): void    {        $tokens = $this-&gt;tokenizer-&gt;tokenize($code);        $ast = $this-&gt;lexer-&gt;lexify($tokens);        foreach ($ast as $node) {            // parse...        }    }}</code></pre><h3 id="不要用标示作为函数的参数"><a href="#不要用标示作为函数的参数" class="headerlink" title="不要用标示作为函数的参数"></a>不要用标示作为函数的参数</h3><p>标示就是在告诉大家，这个方法里处理很多事。前面刚说过，一个函数应当只做一件事。 把不同标示的代码拆分到多个函数里。</p><p><strong>不友好的:</strong></p><pre><code class="php">function createFile(string $name, bool $temp = false): void{    if ($temp) {        touch(&#39;./temp/&#39;.$name);    } else {        touch($name);    }}</code></pre><p><strong>友好的:</strong></p><pre><code class="php">function createFile(string $name): void{    touch($name);}function createTempFile(string $name): void{    touch(&#39;./temp/&#39;.$name);}</code></pre><h3 id="避免副作用"><a href="#避免副作用" class="headerlink" title="避免副作用"></a>避免副作用</h3><p>一个函数应该只获取数值，然后返回另外的数值，如果在这个过程中还做了其他的事情，我们就称为副作用。副作用可能是写入一个文件，修改某些全局变量，或者意外的把你全部的钱给了陌生人。</p><p>现在，你的确需要在一个程序或者场合里要有副作用，像之前的例子，你也许需要写一个文件。你需要做的是把你做这些的地方集中起来。不要用几个函数和类来写入一个特定的文件。只允许使用一个服务来单独实现。</p><p>重点是避免常见陷阱比如对象间共享无结构的数据、使用可以写入任何的可变数据类型、不集中去处理这些副作用。如果你做了这些你就会比大多数程序员快乐。</p><p><strong>不好的:</strong></p><pre><code class="php">// 这个全局变量在函数中被使用// 如果我们在别的方法中使用这个全局变量，有可能我们会不小心将其修改为数组类型$name = &#39;Ryan McDermott&#39;;function splitIntoFirstAndLastName(): void{    global $name;    $name = explode(&#39; &#39;, $name);}splitIntoFirstAndLastName();var_dump($name); // [&#39;Ryan&#39;, &#39;McDermott&#39;];</code></pre><p><strong>推荐的:</strong></p><pre><code class="php">function splitIntoFirstAndLastName(string $name): array{    return explode(&#39; &#39;, $name);}$name = &#39;Ryan McDermott&#39;;$newName = splitIntoFirstAndLastName($name);var_dump($name); // &#39;Ryan McDermott&#39;;var_dump($newName); // [&#39;Ryan&#39;, &#39;McDermott&#39;];</code></pre><h3 id="不要定义全局函数"><a href="#不要定义全局函数" class="headerlink" title="不要定义全局函数"></a>不要定义全局函数</h3><p>在很多语言中定义全局函数是一个坏习惯，因为你定义的全局函数可能与其他人的函数库冲突，并且，除非在实际运用中遇到异常，否则你的 API 的使用者将无法觉察到这一点。接下来我们来看看一个例子：当你想有一个配置数组，你可能会写一个 <code>config()</code> 的全局函数，但是这样会与其他人定义的库冲突。</p><p><strong>不好的:</strong></p><pre><code class="php">function config(): array{    return  [        &#39;foo&#39; =&gt; &#39;bar&#39;,    ]}</code></pre><p><strong>好的:</strong></p><pre><code class="php">class Configuration{    private $configuration = [];    public function __construct(array $configuration)    {        $this-&gt;configuration = $configuration;    }    public function get(string $key): ?string    {        return isset($this-&gt;configuration[$key]) ? $this-&gt;configuration[$key] : null;    }}</code></pre><p>获取配置需要先创建 <code>Configuration</code> 类的实例，如下：</p><pre><code class="php">$configuration = new Configuration([    &#39;foo&#39; =&gt; &#39;bar&#39;,]);</code></pre><p>现在，在你的应用中必须使用 <code>Configuration</code> 的实例了。</p><h3 id="不要使用单例模式"><a href="#不要使用单例模式" class="headerlink" title="不要使用单例模式"></a>不要使用单例模式</h3><p>单例模式是个 <a href="https://en.wikipedia.org/wiki/Singleton_pattern" target="_blank" rel="noopener">反模式</a>。 以下转述 Brian Button 的观点：</p><ol><li>单例模式常用于 <strong>全局实例</strong>， 这么做为什么不好呢？ 因为在你的代码里 <strong>你隐藏了应用的依赖关系</strong>，而没有通过接口公开依赖关系 。避免全局的东西扩散使用是一种 <a href="https://en.wikipedia.org/wiki/Code_smell" target="_blank" rel="noopener">代码味道</a>.</li><li>单例模式违反了 <a href="https://learnku.com/laravel/t/7774/the-conciseness-of-the-php-code-php-clean-code#single-responsibility-principle-srp" target="_blank" rel="noopener">单一责任原则</a>： 依据的事实就是 <strong>单例模式自己控制自身的创建和生命周期</strong>.</li><li>单例模式天生就导致代码紧 <a href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)" target="_blank" rel="noopener">耦合</a>。这使得在许多情况下用伪造的数据 <strong>难于测试</strong>。</li><li>单例模式的状态会留存于应用的整个生命周期。 这会对测试产生第二次打击，<strong>你只能让被严令需要测试的代码运行不了</strong>收场，根本不能进行单元测试。为何？因为每一个单元测试应该彼此独立。</li></ol><p>还有些来自 <a href="http://misko.hevery.com/about/" target="_blank" rel="noopener">Misko Hevery</a> 的深入思考，关于单例模式的 <a href="http://misko.hevery.com/2008/08/25/root-cause-of-singletons/" target="_blank" rel="noopener">问题根源</a>。</p><p><strong>不好的示范：</strong></p><pre><code class="php">class DBConnection{    private static $instance;    private function __construct(string $dsn)    {        // ...    }    public static function getInstance(): DBConnection    {        if (self::$instance === null) {            self::$instance = new self();        }        return self::$instance;    }    // ...}$singleton = DBConnection::getInstance();</code></pre><p><strong>好的示范：</strong></p><pre><code class="php">class DBConnection{    public function __construct(string $dsn)    {        // ...    }     // ...}</code></pre><p>用 <a href="http://php.net/manual/en/pdo.construct.php#refsect1-pdo.construct-parameters" target="_blank" rel="noopener">DSN</a> 进行配置创建的 <code>DBConnection</code> 类实例。</p><pre><code class="php">$connection = new DBConnection($dsn);</code></pre><p>现在就必须在你的应用中使用 <code>DBConnection</code> 的实例了。</p><h3 id="封装条件语句"><a href="#封装条件语句" class="headerlink" title="封装条件语句"></a>封装条件语句</h3><p><strong>不友好的:</strong></p><pre><code class="php">if ($article-&gt;state === &#39;published&#39;) {    // ...}</code></pre><p><strong>友好的:</strong></p><pre><code class="php">if ($article-&gt;isPublished()) {    // ...}</code></pre><h3 id="避免用反义条件判断"><a href="#避免用反义条件判断" class="headerlink" title="避免用反义条件判断"></a>避免用反义条件判断</h3><p><strong>不友好的:</strong></p><pre><code class="php">function isDOMNodeNotPresent(\DOMNode $node): bool{    // ...}if (!isDOMNodeNotPresent($node)){    // ...}</code></pre><p><strong>友好的:</strong></p><pre><code class="php">function isDOMNodePresent(\DOMNode $node): bool{    // ...}if (isDOMNodePresent($node)) {    // ...}</code></pre><h3 id="避免使用条件语句"><a href="#避免使用条件语句" class="headerlink" title="避免使用条件语句"></a>避免使用条件语句</h3><p>这听起来像是个不可能实现的任务。 当第一次听到这个时，大部分人都会说，“没有 <code>if</code> 语句，我该怎么办？” 答案就是在很多情况下你可以使用多态性来实现同样的任务。 接着第二个问题来了， “听着不错，但我为什么需要那样做？”，这个答案就是我们之前所学的干净代码概念：一个函数应该只做一件事情。如果你的类或函数有 <code>if</code> 语句，这就告诉了使用者你的类或函数干了不止一件事情。 记住，只要做一件事情。</p><p><strong>不好的:</strong></p><pre><code class="php">class Airplane{    // ...    public function getCruisingAltitude(): int    {        switch ($this-&gt;type) {            case &#39;777&#39;:                return $this-&gt;getMaxAltitude() - $this-&gt;getPassengerCount();            case &#39;Air Force One&#39;:                return $this-&gt;getMaxAltitude();            case &#39;Cessna&#39;:                return $this-&gt;getMaxAltitude() - $this-&gt;getFuelExpenditure();        }    }}</code></pre><p><strong>好的:</strong></p><pre><code class="php">interface Airplane{    // ...    public function getCruisingAltitude(): int;}class Boeing777 implements Airplane{    // ...    public function getCruisingAltitude(): int    {        return $this-&gt;getMaxAltitude() - $this-&gt;getPassengerCount();    }}class AirForceOne implements Airplane{    // ...    public function getCruisingAltitude(): int    {        return $this-&gt;getMaxAltitude();    }}class Cessna implements Airplane{    // ...    public function getCruisingAltitude(): int    {        return $this-&gt;getMaxAltitude() - $this-&gt;getFuelExpenditure();    }}</code></pre><h3 id="避免类型检测-第-1-部分"><a href="#避免类型检测-第-1-部分" class="headerlink" title="避免类型检测 (第 1 部分)"></a>避免类型检测 (第 1 部分)</h3><p>PHP 是无类型的，这意味着你的函数可以接受任何类型的参数。<br>有时这种自由会让你感到困扰，并且他会让你自然而然的在函数中使用类型检测。有很多方法可以避免这么做。<br>首先考虑 API 的一致性。</p><p><strong>不好的：</strong></p><pre><code class="php">function travelToTexas($vehicle): void{    if ($vehicle instanceof Bicycle) {        $vehicle-&gt;pedalTo(new Location(&#39;texas&#39;));    } elseif ($vehicle instanceof Car) {        $vehicle-&gt;driveTo(new Location(&#39;texas&#39;));    }}</code></pre><p><strong>好的：</strong></p><pre><code class="php">function travelToTexas(Traveler $vehicle): void{    $vehicle-&gt;travelTo(new Location(&#39;texas&#39;));}</code></pre><h3 id="避免类型检查（第-2-部分）"><a href="#避免类型检查（第-2-部分）" class="headerlink" title="避免类型检查（第 2 部分）"></a>避免类型检查（第 2 部分）</h3><p>如果你正在使用像 字符串、数值、或数组这样的基础类型，你使用的是 PHP 版本是 PHP 7+，并且你不能使用多态，但仍然觉得需要使用类型检测，这时，你应该考虑 <a href="http://php.net/manual/en/functions.arguments.php#functions.arguments.type-declaration" target="_blank" rel="noopener">类型定义</a> 或 严格模式。它为您提供了标准 PHP 语法之上的静态类型。<br>手动进行类型检查的问题是做这件事需要这么多的额外言辞，你所得到的虚假的『类型安全』并不能弥补丢失的可读性。保持你的代码简洁，编写良好的测试，并且拥有好的代码审查。<br>否则，使用 PHP 严格的类型声明或严格模式完成所有这些工作。</p><p><strong>不好的：</strong></p><pre><code class="php">function combine($val1, $val2): int{    if (!is_numeric($val1) || !is_numeric($val2)) {        throw new \Exception(&#39;Must be of type Number&#39;);    }    return $val1 + $val2;}</code></pre><p><strong>好的：</strong></p><pre><code class="php">function combine(int $val1, int $val2): int{    return $val1 + $val2;}</code></pre><h3 id="移除无用代码"><a href="#移除无用代码" class="headerlink" title="移除无用代码"></a>移除无用代码</h3><p>无用代码和重复代码一样糟糕。 如果没有被调用，就应该把它删除掉，没必要将它保留在你的代码库中！当你需要它的时候，可以在你的历史版本中找到它。</p><p><strong>Bad:</strong></p><pre><code class="php">function oldRequestModule(string $url): void{    // ...}function newRequestModule(string $url): void{    // ...}$request = newRequestModule($requestUrl);inventoryTracker(&#39;apples&#39;, $request, &#39;www.inventory-awesome.io&#39;);</code></pre><p><strong>Good:</strong></p><pre><code class="php">function requestModule(string $url): void{    // ...}$request = requestModule($requestUrl);inventoryTracker(&#39;apples&#39;, $request, &#39;www.inventory-awesome.io&#39;);</code></pre><h2 id="对象和数据结构"><a href="#对象和数据结构" class="headerlink" title="对象和数据结构"></a>对象和数据结构</h2><h3 id="使用对象封装"><a href="#使用对象封装" class="headerlink" title="使用对象封装"></a>使用对象封装</h3><p>在 PHP 中，你可以在方法中使用关键字，如 <code>public</code>, <code>protected</code> and <code>private</code>。<br>使用它们，你可以任意的控制、修改对象的属性。</p><ul><li>当你除获取对象属性外还想做更多的操作时，你不需要修改你的代码</li><li>当 <code>set</code> 属性时，易于增加参数验证。</li><li>封装的内部表示。</li><li>容易在获取和设置属性时添加日志和错误处理。</li><li>继承这个类，你可以重写默认信息。</li><li>你可以延迟加载对象的属性，比如从服务器获取数据。</li></ul><p>此外，这样的方式也符合 OOP 开发中的 [开闭原则](# 开闭原则 (OCP))</p><p><strong>不好的:</strong></p><pre><code class="php">class BankAccount{    public $balance = 1000;}$bankAccount = new BankAccount();// Buy shoes...$bankAccount-&gt;balance -= 100;</code></pre><p><strong>好的:</strong></p><pre><code class="php">class BankAccount{    private $balance;    public function __construct(int $balance = 1000)    {      $this-&gt;balance = $balance;    }    public function withdraw(int $amount): void    {        if ($amount &gt; $this-&gt;balance) {            throw new \Exception(&#39;Amount greater than available balance.&#39;);        }        $this-&gt;balance -= $amount;    }    public function deposit(int $amount): void    {        $this-&gt;balance += $amount;    }    public function getBalance(): int    {        return $this-&gt;balance;    }}$bankAccount = new BankAccount();// Buy shoes...$bankAccount-&gt;withdraw($shoesPrice);// Get balance$balance = $bankAccount-&gt;getBalance();</code></pre><h3 id="让对象拥有-private-protected-属性的成员"><a href="#让对象拥有-private-protected-属性的成员" class="headerlink" title="让对象拥有 private/protected 属性的成员"></a>让对象拥有 private/protected 属性的成员</h3><ul><li><code>public</code> 公有方法和属性对于变化来说是最危险的，因为一些外部的代码可能会轻易的依赖他们，但是你没法控制那些依赖他们的代码。 <strong>类的变化对于类的所有使用者来说都是危险的。</strong></li><li><code>protected</code> 受保护的属性变化和 public 公有的同样危险，因为他们在子类范围内是可用的。也就是说 public 和 protected 之间的区别仅仅在于访问机制，只有封装才能保证属性是一致的。<strong>任何在类内的变化对于所有继承子类来说都是危险的 。</strong></li><li><code>private</code> 私有属性的变化可以保证代码 <strong>只对单个类范围内的危险</strong> (对于修改你是安全的，并且你不会有其他类似堆积木的影响 <a href="http://www.urbandictionary.com/define.php?term=Jengaphobia&defid=2494196" target="_blank" rel="noopener">Jenga effect</a>).</li></ul><p>因此，请默认使用 <code>private</code> 属性，只有当需要对外部类提供访问属性的时候才采用 <code>public/protected</code> 属性。</p><p>更多的信息可以参考 <a href="https://github.com/fabpot" target="_blank" rel="noopener">Fabien Potencier</a> 写的针对这个专栏的文章 <a href="http://fabien.potencier.org/pragmatism-over-theory-protected-vs-private.html" target="_blank" rel="noopener">blog post</a> .</p><p><strong>Bad:</strong></p><pre><code class="php">class Employee{    public $name;    public function __construct(string $name)    {        $this-&gt;name = $name;    }}$employee = new Employee(&#39;John Doe&#39;);echo &#39;Employee name: &#39;.$employee-&gt;name; // Employee name: John Doe</code></pre><p><strong>Good:</strong></p><pre><code class="php">class Employee{    private $name;    public function __construct(string $name)    {        $this-&gt;name = $name;    }    public function getName(): string    {        return $this-&gt;name;    }}$employee = new Employee(&#39;John Doe&#39;);echo &#39;Employee name: &#39;.$employee-&gt;getName(); // Employee name: John Doe</code></pre><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="组合优于继承"><a href="#组合优于继承" class="headerlink" title="组合优于继承"></a>组合优于继承</h3><p>正如 the Gang of Four 所著的 <a href="https://en.wikipedia.org/wiki/Design_Patterns" target="_blank" rel="noopener"><em>设计模式</em></a> 中所说，<br>我们应该尽量优先选择组合而不是继承的方式。使用继承和组合都有很多好处。<br>这个准则的主要意义在于当你本能的使用继承时，试着思考一下<strong>组合</strong>是否能更好对你的需求建模。<br>在一些情况下，是这样的。</p><p>接下来你或许会想，“那我应该在什么时候使用继承？”<br>答案依赖于你的问题，当然下面有一些何时继承比组合更好的说明：</p><ol><li>你的继承表达了 “是一个” 而不是 “有一个” 的关系（例如人类 “是” 动物，而用户 “有” 用户详情）。</li><li>你可以复用基类的代码（人类可以像动物一样移动）。</li><li>你想通过修改基类对所有派生类做全局的修改（当动物移动时，修改它们的能量消耗）。</li></ol><p><strong>糟糕的:</strong></p><pre><code class="php">class Employee {    private $name;    private $email;    public function __construct(string $name, string $email)    {        $this-&gt;name = $name;        $this-&gt;email = $email;    }    // ...}// 不好，因为Employees &quot;有&quot; taxdata// 而EmployeeTaxData不是Employee类型的class EmployeeTaxData extends Employee {    private $ssn;    private $salary;    public function __construct(string $name, string $email, string $ssn, string $salary)    {        parent::__construct($name, $email);        $this-&gt;ssn = $ssn;        $this-&gt;salary = $salary;    }    // ...}</code></pre><p><strong>棒棒哒:</strong></p><pre><code class="php">class EmployeeTaxData {    private $ssn;    private $salary;    public function __construct(string $ssn, string $salary)    {        $this-&gt;ssn = $ssn;        $this-&gt;salary = $salary;    }    // ...}class Employee {    private $name;    private $email;    private $taxData;    public function __construct(string $name, string $email)    {        $this-&gt;name = $name;        $this-&gt;email = $email;    }    public function setTaxData(string $ssn, string $salary)    {        $this-&gt;taxData = new EmployeeTaxData($ssn, $salary);    }    // ...}</code></pre><h3 id="避免流式接口"><a href="#避免流式接口" class="headerlink" title="避免流式接口"></a>避免流式接口</h3><p><a href="https://en.wikipedia.org/wiki/Fluent_interface" target="_blank" rel="noopener">流式接口</a> 是一种面向对象 API 的方法，旨在通过方法链 <a href="https://en.wikipedia.org/wiki/Method_chaining" target="_blank" rel="noopener">Method chaining</a> 来提高源代码的可阅读性.</p><p>流式接口虽然需要一些上下文，需要经常构建对象，但是这种模式减少了代码的冗余度 (例如： <a href="https://phpunit.de/manual/current/en/test-doubles.html" target="_blank" rel="noopener">PHPUnit Mock Builder</a><br>或 <a href="http://docs.doctrine-project.org/projects/doctrine-dbal/en/latest/reference/query-builder.html" target="_blank" rel="noopener">Doctrine Query Builder</a>)</p><p>但是同样它也带来了很多麻烦:</p><ol><li>破坏了封装 <a href="https://en.wikipedia.org/wiki/Encapsulation_(object-oriented_programming)" target="_blank" rel="noopener">Encapsulation</a></li><li>破坏了原型 <a href="https://en.wikipedia.org/wiki/Decorator_pattern" target="_blank" rel="noopener">Decorators</a></li><li>难以模拟测试 <a href="https://en.wikipedia.org/wiki/Mock_object" target="_blank" rel="noopener">mock</a></li><li>使得多次提交的代码难以理解</li></ol><p>更多信息可以参考 <a href="https://github.com/Ocramius" target="_blank" rel="noopener">Marco Pivetta</a> 撰写的关于这个专题的文章 <a href="https://ocramius.github.io/blog/fluent-interfaces-are-evil/" target="_blank" rel="noopener">blog post</a></p><p><strong>Bad:</strong></p><pre><code class="php">class Car{    private $make = &#39;Honda&#39;;    private $model = &#39;Accord&#39;;    private $color = &#39;white&#39;;    public function setMake(string $make): self    {        $this-&gt;make = $make;        // NOTE: Returning this for chaining        return $this;    }    public function setModel(string $model): self    {        $this-&gt;model = $model;        // NOTE: Returning this for chaining        return $this;    }    public function setColor(string $color): self    {        $this-&gt;color = $color;        // NOTE: Returning this for chaining        return $this;    }    public function dump(): void    {        var_dump($this-&gt;make, $this-&gt;model, $this-&gt;color);    }}$car = (new Car())  -&gt;setColor(&#39;pink&#39;)  -&gt;setMake(&#39;Ford&#39;)  -&gt;setModel(&#39;F-150&#39;)  -&gt;dump();</code></pre><p><strong>Good:</strong></p><pre><code class="php">class Car{    private $make = &#39;Honda&#39;;    private $model = &#39;Accord&#39;;    private $color = &#39;white&#39;;    public function setMake(string $make): void    {        $this-&gt;make = $make;    }    public function setModel(string $model): void    {        $this-&gt;model = $model;    }    public function setColor(string $color): void    {        $this-&gt;color = $color;    }    public function dump(): void    {        var_dump($this-&gt;make, $this-&gt;model, $this-&gt;color);    }}$car = new Car();$car-&gt;setColor(&#39;pink&#39;);$car-&gt;setMake(&#39;Ford&#39;);$car-&gt;setModel(&#39;F-150&#39;);$car-&gt;dump();</code></pre><h2 id="SOLID"><a href="#SOLID" class="headerlink" title="SOLID"></a>SOLID</h2><p><strong>SOLID</strong> 是 Michael Feathers 推荐的便于记忆的首字母简写，它代表了 Robert Martin 命名的最重要的五个面向对象编程设计原则：</p><ul><li><a href="https://learnku.com/laravel/t/7774/the-conciseness-of-the-php-code-php-clean-code#single-responsibility-principle-srp" target="_blank" rel="noopener">S: 职责单一原则 (SRP)</a></li><li><a href="https://learnku.com/laravel/t/7774/the-conciseness-of-the-php-code-php-clean-code#openclosed-principle-ocp" target="_blank" rel="noopener">O: 开闭原则 (OCP)</a></li><li><a href="https://learnku.com/laravel/t/7774/the-conciseness-of-the-php-code-php-clean-code#liskov-substitution-principle-lsp" target="_blank" rel="noopener">L: 里氏替换原则 (LSP)</a></li><li><a href="https://learnku.com/laravel/t/7774/the-conciseness-of-the-php-code-php-clean-code#interface-segregation-principle-isp" target="_blank" rel="noopener">I: 接口隔离原则 (ISP)</a></li><li><a href="https://learnku.com/laravel/t/7774/the-conciseness-of-the-php-code-php-clean-code#dependency-inversion-principle-dip" target="_blank" rel="noopener">D: 依赖反转原则 (DIP)</a></li></ul><h3 id="职责单一原则-Single-Responsibility-Principle-SRP"><a href="#职责单一原则-Single-Responsibility-Principle-SRP" class="headerlink" title="职责单一原则 Single Responsibility Principle (SRP)"></a>职责单一原则 Single Responsibility Principle (SRP)</h3><p>正如 <em>Clean Code</em> 书中所述，”修改一个类应该只为一个理由”。人们总是容易去用一堆方法 “塞满” 一个类，就好像当我们坐飞机上只能携带一个行李箱时，会把所有的东西都塞到这个箱子里。这样做带来的后果是：从逻辑上讲，这样的类不是高内聚的，并且留下了很多以后去修改它的理由。<br>将你需要修改类的次数降低到最小很重要，这是因为，当类中有很多方法时，修改某一处，你很难知晓在整个代码库中有哪些依赖于此的模块会被影响。</p><p><strong>比较糟:</strong></p><pre><code class="php">class UserSettings{    private $user;    public function __construct(User $user)    {        $this-&gt;user = $user;    }    public function changeSettings(array $settings): void    {        if ($this-&gt;verifyCredentials()) {            // ...        }    }    private function verifyCredentials(): bool    {        // ...    }}</code></pre><p><strong>棒棒哒:</strong></p><pre><code class="php">class UserAuth {    private $user;    public function __construct(User $user)    {        $this-&gt;user = $user;    }    public function verifyCredentials(): bool    {        // ...    }}class UserSettings {    private $user;    private $auth;    public function __construct(User $user)     {        $this-&gt;user = $user;        $this-&gt;auth = new UserAuth($user);    }    public function changeSettings(array $settings): void    {        if ($this-&gt;auth-&gt;verifyCredentials()) {            // ...        }    }}</code></pre><h3 id="开闭原则-OCP"><a href="#开闭原则-OCP" class="headerlink" title="开闭原则 (OCP)"></a>开闭原则 (OCP)</h3><p>如 Bertrand Meyer 所述，”软件实体 (类，模块，功能，等) 应该对扩展开放，但对修改关闭.” 这意味着什么？这个原则大体上是指你应该允许用户在不修改已有代码情况下添加功能.</p><p><strong>坏的:</strong></p><pre><code class="php">abstract class Adapter{    protected $name;    public function getName(): string    {        return $this-&gt;name;    }}class AjaxAdapter extends Adapter{    public function __construct()    {        parent::__construct();        $this-&gt;name = &#39;ajaxAdapter&#39;;    }}class NodeAdapter extends Adapter{    public function __construct()    {        parent::__construct();        $this-&gt;name = &#39;nodeAdapter&#39;;    }}class HttpRequester{    private $adapter;    public function __construct(Adapter $adapter)    {        $this-&gt;adapter = $adapter;    }    public function fetch(string $url): Promise    {        $adapterName = $this-&gt;adapter-&gt;getName();        if ($adapterName === &#39;ajaxAdapter&#39;) {            return $this-&gt;makeAjaxCall($url);        } elseif ($adapterName === &#39;httpNodeAdapter&#39;) {            return $this-&gt;makeHttpCall($url);        }    }    private function makeAjaxCall(string $url): Promise    {        // request and return promise    }    private function makeHttpCall(string $url): Promise    {        // request and return promise    }}</code></pre><p><strong>好的:</strong></p><pre><code class="php">interface Adapter{    public function request(string $url): Promise;}class AjaxAdapter implements Adapter{    public function request(string $url): Promise    {        // request and return promise    }}class NodeAdapter implements Adapter{    public function request(string $url): Promise    {        // request and return promise    }}class HttpRequester{    private $adapter;    public function __construct(Adapter $adapter)    {        $this-&gt;adapter = $adapter;    }    public function fetch(string $url): Promise    {        return $this-&gt;adapter-&gt;request($url);    }}</code></pre><h3 id="里氏代换原则-LSP"><a href="#里氏代换原则-LSP" class="headerlink" title="里氏代换原则 (LSP)"></a>里氏代换原则 (LSP)</h3><p>这是一个简单概念的可怕术语。它通常被定义为 “如果 S 是 T 的一个子类型，则 T 型对象可以替换为 S 型对象”<br>(i.e., S 类型的对象可以替换 T 型对象) 在不改变程序的任何理想属性的情况下 (正确性，任务完成度，etc.).” 这是一个更可怕的定义.<br>这个的最佳解释是，如果你有个父类和一个子类，然后父类和子类可以互换使用而不会得到不正确的结果。这或许依然令人疑惑，所以我们来看下经典的正方形 - 矩形例子。几何定义，正方形是矩形，但是，如果你通过继承建立了 “IS-a” 关系的模型，你很快就会陷入麻烦。.</p><p><strong>不好的:</strong></p><pre><code class="php">class Rectangle{    protected $width = 0;    protected $height = 0;    public function render(int $area): void    {        // ...    }    public function setWidth(int $width): void    {        $this-&gt;width = $width;    }    public function setHeight(int $height): void    {        $this-&gt;height = $height;    }    public function getArea(): int    {        return $this-&gt;width * $this-&gt;height;    }}class Square extends Rectangle{    public function setWidth(int $width): void    {        $this-&gt;width = $this-&gt;height = $width;    }    public function setHeight(int $height): void    {        $this-&gt;width = $this-&gt;height = $height;    }}/** * @param Rectangle[] $rectangles */function renderLargeRectangles(array $rectangles): void{    foreach ($rectangles as $rectangle) {        $rectangle-&gt;setWidth(4);        $rectangle-&gt;setHeight(5);        $area = $rectangle-&gt;getArea(); // BAD: Will return 25 for Square. Should be 20.        $rectangle-&gt;render($area);    }}$rectangles = [new Rectangle(), new Rectangle(), new Square()];renderLargeRectangles($rectangles);</code></pre><p><strong>优秀的:</strong></p><pre><code class="php">abstract class Shape{    abstract public function getArea(): int;    public function render(int $area): void    {        // ...    }}class Rectangle extends Shape{    private $width;    private $height;    public function __construct(int $width, int $height)    {        $this-&gt;width = $width;        $this-&gt;height = $height;    }    public function getArea(): int    {        return $this-&gt;width * $this-&gt;height;    }}class Square extends Shape{    private $length;    public function __construct(int $length)    {        $this-&gt;length = $length;    }    public function getArea(): int    {        return pow($this-&gt;length, 2);    }}/** * @param Rectangle[] $rectangles */function renderLargeRectangles(array $rectangles): void{    foreach ($rectangles as $rectangle) {        $area = $rectangle-&gt;getArea();         $rectangle-&gt;render($area);    }}$shapes = [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];renderLargeRectangles($shapes);</code></pre><h3 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则 (ISP)"></a>接口隔离原则 (ISP)</h3><p>ISP 指出 “客户不应该被强制依赖于他们用不到的接口.”</p><p>一个好的例子来观察证实此原则的是针对需要大量设置对象的类，不要求客户端设置大量的选项是有益的，因为多数情况下他们不需要所有的设置。使他们可选来避免产生一个 “臃肿的接口”.</p><p><strong>坏的:</strong></p><pre><code class="php">interface Employee{    public function work(): void;    public function eat(): void;}class Human implements Employee{    public function work(): void    {        // ....working    }    public function eat(): void    {        // ...... eating in lunch break    }}class Robot implements Employee{    public function work(): void    {        //.... working much more    }    public function eat(): void    {        //.... robot can&#39;t eat, but it must implement this method    }}</code></pre><p><strong>好的:</strong></p><p>并不是每个工人都是雇员，但每个雇员都是工人.</p><pre><code class="php">interface Workable{    public function work(): void;}interface Feedable{    public function eat(): void;}interface Employee extends Feedable, Workable{}class Human implements Employee{    public function work(): void    {        // ....working    }    public function eat(): void    {        //.... eating in lunch break    }}// robot can only workclass Robot implements Workable{    public function work(): void    {        // ....working    }}</code></pre><h3 id="依赖反转原则-DIP"><a href="#依赖反转原则-DIP" class="headerlink" title="依赖反转原则 (DIP)"></a>依赖反转原则 (DIP)</h3><p>这一原则规定了两项基本内容:</p><ol><li>高级模块不应依赖于低级模块。两者都应该依赖于抽象.</li><li>抽象类不应依赖于实例。实例应该依赖于抽象.</li></ol><p>一开始可能很难去理解，但是你如果工作中使用过 php 框架（如 Symfony）, 你应该见过以依赖的形式执行这一原则<br>依赖注入 (DI). 虽然他们不是相同的概念，DIP 可以让高级模块不需要了解其低级模块的详细信息而安装它们.<br>通过依赖注入可以做到。这样做的一个巨大好处是减少了模块之间的耦合。耦合是一种非常糟糕的开发模式，因为它使您的代码难以重构.</p><p><strong>不好的:</strong></p><pre><code class="php">class Employee{    public function work(): void    {        // ....working    }}class Robot extends Employee{    public function work(): void    {        //.... working much more    }}class Manager{    private $employee;    public function __construct(Employee $employee)    {        $this-&gt;employee = $employee;    }    public function manage(): void    {        $this-&gt;employee-&gt;work();    }}</code></pre><p><strong>优秀的:</strong></p><pre><code class="php">interface Employee{    public function work(): void;}class Human implements Employee{    public function work(): void    {        // ....working    }}class Robot implements Employee{    public function work(): void    {        //.... working much more    }}class Manager{    private $employee;    public function __construct(Employee $employee)    {        $this-&gt;employee = $employee;    }    public function manage(): void    {        $this-&gt;employee-&gt;work();    }}</code></pre><h2 id="别写重复代码-DRY"><a href="#别写重复代码-DRY" class="headerlink" title="别写重复代码 (DRY)"></a>别写重复代码 (DRY)</h2><p>试着去遵循 <a href="https://en.wikipedia.org/wiki/Don' target="_blank" rel="noopener"t_repeat_yourself">DRY</a> 原则。</p><p>尽你最大的努力去避免复制代码，它是一种非常糟糕的行为，复制代码通常意味着当你需要变更一些逻辑时，你需要修改不止一处。</p><p>试想一下，如果你在经营一家餐厅，并且你需要记录你仓库的进销记录：包括所有的土豆，洋葱，大蒜，辣椒，等等。如果你使用多个表格来管理进销记录，当你用其中一些土豆做菜时，你需要更新所有的表格。如果你只有一个列表的话就只需要更新一个地方。</p><p>通常情况下你复制代码的原因可能是它们大多数都是一样的，只不过有两个或者多个略微不同的逻辑，但是由于这些区别，最终导致你写出了两个或者多个隔离的但大部分相同的方法，移除重复的代码意味着用一个 function/module/class 创建一个能处理差异的抽象。</p><p>正确的抽象是非常关键的，这正是为什么你必须学习遵守在 <a href="https://learnku.com/laravel/t/7774/the-conciseness-of-the-php-code-php-clean-code#classes" target="_blank" rel="noopener">Classes</a> 章节展开讨论的的 <strong>SOLID</strong> 原则，不合理的抽象比复制代码更糟糕，所以请务必谨慎！说了这么多，如果你能设计一个合理的抽象，就去实现它！最后再说一遍，不要写重复代码，否则你会发现当你想修改一个逻辑时，你必须去修改多个地方！</p><p><strong>糟糕的:</strong></p><pre><code class="php">function showDeveloperList(array $developers): void{    foreach ($developers as $developer) {        $expectedSalary = $developer-&gt;calculateExpectedSalary();        $experience = $developer-&gt;getExperience();        $githubLink = $developer-&gt;getGithubLink();        $data = [            $expectedSalary,            $experience,            $githubLink        ];        render($data);    }}function showManagerList(array $managers): void{    foreach ($managers as $manager) {        $expectedSalary = $manager-&gt;calculateExpectedSalary();        $experience = $manager-&gt;getExperience();        $githubLink = $manager-&gt;getGithubLink();        $data = [            $expectedSalary,            $experience,            $githubLink        ];        render($data);    }}</code></pre><p><strong>好的:</strong></p><pre><code class="php">function showList(array $employees): void{    foreach ($employees as $employee) {        $expectedSalary = $employee-&gt;calculateExpectedSalary();        $experience = $employee-&gt;getExperience();        $githubLink = $employee-&gt;getGithubLink();        $data = [            $expectedSalary,            $experience,            $githubLink        ];        render($data);    }}</code></pre><p><strong>非常好:</strong></p><p>最好让你的代码紧凑一点。</p><pre><code class="php">function showList(array $employees): void{    foreach ($employees as $employee) {        render([            $employee-&gt;calculateExpectedSalary(),            $employee-&gt;getExperience(),            $employee-&gt;getGithubLink()        ]);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;PHP-代码简洁之道&quot;&gt;&lt;a href=&quot;#PHP-代码简洁之道&quot; class=&quot;headerlink&quot; title=&quot;PHP 代码简洁之道&quot;&gt;&lt;/a&gt;PHP 代码简洁之道&lt;/h2&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://ljheisenberg1072.github.io/categories/PHP/"/>
    
    
      <category term="Clean" scheme="https://ljheisenberg1072.github.io/tags/Clean/"/>
    
  </entry>
  
  <entry>
    <title>手动部署 Laravel 应用</title>
    <link href="https://ljheisenberg1072.github.io/2019/11/20/deploy-laravel-project-byhands/"/>
    <id>https://ljheisenberg1072.github.io/2019/11/20/deploy-laravel-project-byhands/</id>
    <published>2019-11-20T04:30:44.000Z</published>
    <updated>2021-04-27T02:55:50.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="手动部署-Laravel-应用（基于Ubuntu18-04）"><a href="#手动部署-Laravel-应用（基于Ubuntu18-04）" class="headerlink" title="手动部署 Laravel 应用（基于Ubuntu18.04）"></a>手动部署 Laravel 应用（基于Ubuntu18.04）</h2><h3 id="0-腾讯云服务器需要注意"><a href="#0-腾讯云服务器需要注意" class="headerlink" title="0. 腾讯云服务器需要注意"></a>0. 腾讯云服务器需要注意</h3><ol><li>禁用<code>systemd-resolved</code>服务</li></ol><pre><code class="bash">$ systemctl stop systemd-resolved$ systemctl disable systemd-resolved</code></pre><ol start="2"><li>编辑<code>/etc/resolv.conf</code>文件，默认是<code>127.0.0.53</code></li></ol><pre><code class="bash">$ nameserver 127.0.0.53            # 原始$ nameserver 114.114.114.114    # 替换后</code></pre><ol start="3"><li>注意<code>/etc/apt/source.list</code>中的源地址<br>把<code>mirrors.tencentyun.com</code>替换成<code>mirrors.cloud.tencent.com</code>，否则镜像有问题</li></ol><h3 id="1-初始化系统"><a href="#1-初始化系统" class="headerlink" title="1. 初始化系统"></a>1. 初始化系统</h3><ol><li>更新软件源</li></ol><pre><code class="bash">$ apt update</code></pre><ol start="2"><li>查看可升级软件包，并升级（生产环境谨慎操作）</li></ol><pre><code class="bash">$ apt list --upgradable$ apt upgrade</code></pre><ol start="3"><li>本地化配置（国内服务器都已经配置好）</li></ol><pre><code class="bash">$ locale-gen en_US.UTF-8$ update-locale LC_ALL=en_US.UTF-8$ timedatectl set-timezone Asia/Shanghai</code></pre><h3 id="2-安装-Nginx"><a href="#2-安装-Nginx" class="headerlink" title="2. 安装 Nginx"></a>2. 安装 Nginx</h3><ol><li>安装 Nginx</li></ol><pre><code class="bash">$ apt install nginx</code></pre><ol start="2"><li>管理 Nginx 服务</li></ol><pre><code class="bash">$ service nginx start        # 启动 Nginx$ service nginx stop        # 停止 Nginx$ service nginx restart        # 重启 Nginx$ systemctl enable nginx    # 启用 Nginx 开机启动$ systemctl disable nginx     # 禁用 Nginx 开机启动</code></pre><ol start="3"><li>确认 Nginx 正常运行</li></ol><p>在浏览器内输入服务器公网 IP（或域名）并打开，出现欢迎界面说明 Nginx 安装成功</p><h3 id="3-安装-PHP-FPM"><a href="#3-安装-PHP-FPM" class="headerlink" title="3. 安装 PHP-FPM"></a>3. 安装 PHP-FPM</h3><ol><li>配置第三方软件源</li></ol><pre><code class="bash">$ apt install -y software-properties-common$ add-apt-repository -y ppa:ondrej/php$ apt-get update</code></pre><ol start="2"><li>安装 PHP</li></ol><p>PHP 的安装分为三个软件包：PHP、PHP-CLI、PHP-FPM</p><pre><code class="bash">$ apt install -y php7.2 php7.2-cli php7.2-fpm</code></pre><ol start="3"><li>安装 PHP 必要的扩展</li></ol><pre><code class="bash">$ apt install -y php7.2-mbstring php7.2-xml php7.2-bcmath php7.2-curl php7.2-gd php7.2-mysql php7.2-opcache php7.2-zip php7.2-sqlite3 php7.2-json</code></pre><ol start="4"><li>根据命令搜索当前软件源内包</li></ol><pre><code class="bash">$ apt-cache search php7.2</code></pre><ol start="5"><li>管理 PHP-FPM 服务</li></ol><pre><code class="bash">$ service php7.2-fpm restart    # 重启 PHP-FPM$ service php7.2-fpm start        # 启动 PHP-FPM$ service php7.2-fpm stop        # 停止 PHP-FPM$ systemctl enable php7.2-fpm    # 启用 PHP-FPM 开机启动$ systemctl disable php7.2-fpm    # 禁用 PHP-FPM 开机启动</code></pre><ol start="6"><li>确认 PHP-FPM 正常运行</li></ol><pre><code class="bash">$ ps aux | grep php</code></pre><p>如果 PHP-FPM 进程不存在，则只有 <code>grep</code> 进程</p><h3 id="4-安装-Git-和-Composer"><a href="#4-安装-Git-和-Composer" class="headerlink" title="4. 安装 Git 和 Composer"></a>4. 安装 Git 和 Composer</h3><ol><li>安装 Git</li></ol><pre><code class="bash">$ apt install -y git</code></pre><ol start="2"><li>安装 Composer</li></ol><pre><code class="bash">$ wget https://raw.githubusercontent.com/composer/getcomposer.org/master/web/installer -O - -q | php -- --filename=composer -- install-dir=/usr/local/bin</code></pre><ol start="3"><li>composer 执行权限问题（新建普通用户，防止composer包有恶意代码）</li></ol><pre><code class="bash">$ composer -VDo not run Composer as root/super user!</code></pre><ol start="4"><li>配置 Packagist 中国镜像</li></ol><pre><code class="bash">$ composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/</code></pre><h3 id="5-安全加固，避免使用根目录用户"><a href="#5-安全加固，避免使用根目录用户" class="headerlink" title="5. 安全加固，避免使用根目录用户"></a>5. 安全加固，避免使用根目录用户</h3><ol><li>创建新用户</li></ol><p>在创建新用户前先创建用户组，例如<code>foodaily</code></p><pre><code class="bash">$ addgroup foodailycompany</code></pre><p>随后创建新用户，例如<code>foodaily</code></p><pre><code class="bash">$ useradd -d /home/foodaily -s /bin/bash -m foodaily</code></pre><p>接着将用户添加至用户组：</p><pre><code class="bash">$ usermod -a -G foodailycompany -G www-data foodaily</code></pre><p>最后为新用户设置密码：</p><pre><code class="bash">$ passwd foodaily$ Enter new UNIX password:&lt;输入密码&gt;$ Retype new UNIX password:&lt;再次输入密码&gt;</code></pre><p>切换到新用户下面</p><pre><code class="bash">$ su foodaily</code></pre><p>切换回 root 用户</p><pre><code class="bash">$ su root</code></pre><ol start="2"><li>测试效果</li></ol><p>断开 SSH 链接，在本地使用以下命令作为<code>foodaily</code>用户登录到服务器</p><pre><code class="bash">$ ssh foodaily@公网IP$ foodaily@公网IP&#39;s password:&lt;输入密码&gt;</code></pre><ol start="3"><li>禁止根用户 SSH 登录</li></ol><pre><code class="bash">$ sed -i -E &#39;s/#?\s*(PermitRootLogin)(.*)$/\1 no/&#39; /etc/ssh/sshd_config</code></pre><p>建议手动编辑 <code>/etc/ssh/sshd_config</code> 文件，搜索<code>PermitRootLogin</code>这一关键字，将整行改成<code>PermitRootLogin no</code>，确保正行修改，首尾无多余字符<br>随后重启 SSH 服务即可</p><pre><code class="bash">$ service ssh restart</code></pre><ol start="4"><li>再次测试效果</li></ol><pre><code class="bash">$ ssh root@公网IP$ Permission denied, please try again.</code></pre><p><strong>注意</strong> ：如果要使用<code>root</code>用户，需要先通过<code>foodaily</code>用户 SSH 登录服务器，然后再通过<code>su root</code> 来切换 root 用户</p><h3 id="6-部署应用代码"><a href="#6-部署应用代码" class="headerlink" title="6. 部署应用代码"></a>6. 部署应用代码</h3><ol><li>使用 Git 拉取项目（HTTPS 协议）</li></ol><pre><code class="bash">$ cd /var/www/$ git clone https://github.com/username/demo.git demo$ Username for &#39;https://github.com&#39;: &lt;输入你的用户名&gt;$ Password for &#39;https://example@github.com&#39;: &lt;请输入你的密码&gt;</code></pre><p>私有项目需要输入账号和密码</p><ol start="2"><li>使用 Composer 安装依赖</li></ol><pre><code class="bash">$ cd demo$ composer install</code></pre><p>提示找不到<code>unzip</code>扩展</p><pre><code class="bash">$ apt install unzip</code></pre><ol start="3"><li>使用 Npm 或者 Yarn 安装依赖</li></ol><pre><code class="bash">$ cd demo$ sudo npm/yarn install</code></pre><ol start="4"><li>配置环境变量</li></ol><p>依赖安装完成后，需要将<code>.env.example</code>文件复制为<code>.env</code>文件，并生成<code>APP_KEY</code>秘钥：</p><pre><code class="bash">$ cd /var/www/demo$ php -r &quot;file_exists(&#39;.env&#39;) || copy(&#39;.env.example&#39;, &#39;.env&#39;);&quot;$ php artisan key:generate --ansi</code></pre><ol start="5"><li>配置文件所有者</li></ol><pre><code class="bash">$ chown -R www-data:www-data .</code></pre><h3 id="7-配置-Nginx-站点"><a href="#7-配置-Nginx-站点" class="headerlink" title="7. 配置 Nginx 站点"></a>7. 配置 Nginx 站点</h3><ol><li>在<code>/etc/nginx/sites-enabled</code>文件夹下放置每个网站的conf</li></ol><pre><code class="bash">$ foodaily.conf</code></pre><ol start="2"><li>现成 Nginx 配置如下：</li></ol><pre><code class="php">server {    listen 80;    server_name 公网IP或域名;     # 此为必修改项，请替换为服务器公网 IP 或域名    root /var/www/demo/public; # 此为必修改项，请注意指向站点根目录的 public 子目录    add_header X-Frame-Options &quot;SAMEORIGIN&quot;;    add_header X-XSS-Protection &quot;1; mode=block&quot;;    add_header X-Content-Type-Options &quot;nosniff&quot;;    index index.html index.htm index.php;    charset utf-8;    location / {        try_files $uri $uri/ /index.php?$query_string;    }    location = /favicon.ico { access_log off; log_not_found off; }    location = /robots.txt  { access_log off; log_not_found off; }    error_page 404 /index.php;    location ~ \.php$ {        fastcgi_pass unix:/var/run/php/php7.2-fpm.sock; # 请注意核对 PHP 版本        fastcgi_index index.php;        fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;        include fastcgi_params;    }    location ~ /\.(?!well-known).* {        deny all;    }}</code></pre><p>通常仅需要修改 <code>server_name</code>、<code>root</code>和<code>fastcgi_pass</code>三个选项即可</p><ol start="3"><li>重载 Nginx（三者等价）</li></ol><pre><code class="bash">$ service nginx restart$ service nginx reload$ nginx -s reload</code></pre><ol start="4"><li>Nginx https配置</li></ol><pre><code class="php">server {    listen 443 ssl;    ssl_certificate /usr/local/nginx/ssl/server.crt;    ssl_certificate_key    /usr/local/nginx/ssl/server.key;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers HIGH:!aNULL:!MD5:!DH;    server_name 公网IP或域名;     # 此为必修改项，请替换为服务器公网 IP 或域名    server_name foodaily.com www.foodaily.com;    # 如果有www的要填写两个    root /var/www/demo/public; # 此为必修改项，请注意指向站点根目录的 public 子目录    add_header X-Frame-Options &quot;SAMEORIGIN&quot;;    add_header X-XSS-Protection &quot;1; mode=block&quot;;    add_header X-Content-Type-Options &quot;nosniff&quot;;    index index.html index.htm index.php;    charset utf-8;    location / {        try_files $uri $uri/ /index.php?$query_string;    }    location = /favicon.ico { access_log off; log_not_found off; }    location = /robots.txt  { access_log off; log_not_found off; }    error_page 404 /index.php;    location ~ \.php$ {        fastcgi_pass unix:/var/run/php/php7.2-fpm.sock; # 请注意核对 PHP 版本        fastcgi_index index.php;        fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;        include fastcgi_params;    }    location ~ /\.(?!well-known).* {        deny all;    }}# 全站使用 HTTPS，让通过 HTTP 访问的用户301跳转到 HTTPSserver {    listen    80;    server_name example.com www.example.com;    return 301 https://$server_name$request_uri;}</code></pre><h3 id="8-安装-MySQL-5-7"><a href="#8-安装-MySQL-5-7" class="headerlink" title="8. 安装 MySQL 5.7"></a>8. 安装 MySQL 5.7</h3><ol><li>安装 MySQL</li></ol><pre><code class="bash">$ sudo apt install mysql-server</code></pre><ol start="2"><li>配置 MySQL</li></ol><pre><code class="bash">$ sudo mysql_secure_installation</code></pre><p>在成功设置 root 密码后还有一些列的安全设置</p><ol start="3"><li>安全设置</li></ol><pre><code class="bash">$ Do you wish to continue with the password provided?([Y/n]): y$ Enter current password for root (enter for none): &lt;输入密码&gt;$ Change the root password? [Y/n] n$ Remove anonymous users? [Y/n] y$ Disallow root login remotely? [Y/n] n$ Remove test database and access to it? [Y/n] n$ Reload privilege tables now? [Y/n] y</code></pre><ol start="4"><li>添加用户</li></ol><pre><code class="bash">$ create user usernamexxx identified by &#39;passwordxxx&#39;;</code></pre><p>用户名：usernamexxx，密码：passwordxxx</p><ol start="5"><li>授权</li></ol><pre><code class="bash">$ grant all privileges on db_name.* to usernamexxx@&#39;%&#39; identified by &#39;passwordxxx&#39;;$ flush privileges;</code></pre><p>给用户<code>usernamexxx</code>赋予<code>db_name</code>数据库的所有表的所有权限</p><ol start="6"><li>修改密码</li></ol><pre><code class="bash">$ update mysql.user set password = password(&#39;passwordxxx&#39;) where user = &#39;usernamexxx&#39; and host = &#39;%&#39;;$ flush privileges;</code></pre><ol start="7"><li>删除用户（会删除用户以及对应的权限，mysql.user和mysql.db表的相应记录随之删除）</li></ol><pre><code class="bash">$ drop user usernamexxx@&#39;%&#39;;</code></pre><ol start="8"><li>使用MySQL</li></ol><pre><code class="bash">$ /etc/init.d/mysql start$ /etc/init.d/mysql stop$ /etc/init.d/mysql restart</code></pre><ol start="9"><li>MySQL密码含有特殊字符的话，在<code>.env</code>文件中要加上双引号，否则密码无法完全识别</li></ol><h3 id="9-生产环境的必要优化"><a href="#9-生产环境的必要优化" class="headerlink" title="9. 生产环境的必要优化"></a>9. 生产环境的必要优化</h3><ol><li>Nginx 配置</li></ol><pre><code class="php">server {    location ~* \.(js|css)$ {        expires 24h;    }}</code></pre><ol start="2"><li>Laravel 的配置缓存</li></ol><pre><code class="bash">$ php artisan config:cache        # 生成配置缓存</code></pre><p><strong>注意</strong> ：当开启配置缓存后，<code>env()</code>函数将会失效，它永远返回null，因此务必确保在非config目录下使用env函数。生成缓存后，对配置的修改将不会生效，需要执行下面命令清除它们</p><pre><code class="bash">$ php artisan config:clear        # 清除配置缓存</code></pre><ol start="3"><li>Laravel 的路由缓存</li></ol><pre><code class="bash">$ php artisan route:cache        # 生成路由缓存</code></pre><p><strong>注意</strong>：若路由注册存在闭包，则无法使用该功能，生成缓存后，对路由的修改将不会生效，需要执行下面命令清除它们</p><pre><code class="bash">$ php artisan route:clear        # 清除路由缓存</code></pre><p><strong>注意</strong>：别直接使用下面命令清除所有缓存，因为有可能会清除掉 Redis 缓存</p><pre><code class="bash">$ php artisan cache:clear</code></pre><ol start="3"><li>Composer （安装依赖时）</li></ol><pre><code class="bash">$ composer install --optimize-autoloader --no-dev</code></pre><p>其中<code>--optimize-autoloader</code>表示生成优化后的自动加载器，<code>--no-dev</code>表示不安装composer.json中<code>require-dev</code>声明的扩展包</p><ol start="4"><li>文件权限</li></ol><p>文件权限应当遵守『最小权限原则』，即权限越小越好。</p><pre><code class="bash">$ chmod -R 750 /var/www/demo</code></pre><ol start="5"><li>杂项</li></ol><pre><code class="bash">$ php artisan storage:link        # 软链接，storage/app/public 到 public 目录$ php artisan migrate            # 执行迁移$ php artisan db:seed            # 执行数据填充</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;手动部署-Laravel-应用（基于Ubuntu18-04）&quot;&gt;&lt;a href=&quot;#手动部署-Laravel-应用（基于Ubuntu18-04）&quot; class=&quot;headerlink&quot; title=&quot;手动部署 Laravel 应用（基于Ubuntu18.04）&quot;&gt;
      
    
    </summary>
    
    
      <category term="Laravel" scheme="https://ljheisenberg1072.github.io/categories/Laravel/"/>
    
    
      <category term="部署" scheme="https://ljheisenberg1072.github.io/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
</feed>
