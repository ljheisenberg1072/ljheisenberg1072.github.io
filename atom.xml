<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LJHeisenberg&#39; Blog</title>
  
  <subtitle>ljheisenberg</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ljheisenberg1072.github.io/"/>
  <updated>2019-12-25T02:45:56.576Z</updated>
  <id>https://ljheisenberg1072.github.io/</id>
  
  <author>
    <name>LJHeisenberg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP 代码简洁之道</title>
    <link href="https://ljheisenberg1072.github.io/2019/12/25/php-code-clean/"/>
    <id>https://ljheisenberg1072.github.io/2019/12/25/php-code-clean/</id>
    <published>2019-12-25T02:40:44.000Z</published>
    <updated>2019-12-25T02:45:56.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PHP-代码简洁之道"><a href="#PHP-代码简洁之道" class="headerlink" title="PHP 代码简洁之道"></a>PHP 代码简洁之道</h2><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Robert C.Martin’s 的 软件工程师准则 <a href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882" target="_blank" rel="noopener"><em>Clean Code</em></a> 同样适用于 PHP。它并不是一个编码风格指南，它指导我们用 PHP 写出具有可读性，可复用性且可分解的代码。</p><p>并非所有的准则都必须严格遵守，甚至一些已经成为普遍的约定。这仅仅作为指导方针，其中许多都是 <em>Clean Code</em> 作者们多年来的经验。</p><blockquote><p>灵感来自于 <a href="https://github.com/ryanmcdermott/clean-code-javascript" target="_blank" rel="noopener">clean-code-javascript</a></p></blockquote><p>尽管许多开发者依旧使用 PHP 5 版本，但是这篇文章中绝大多数例子都是只能在 PHP 7.1 + 版本下运行。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="使用有意义的且可读的变量名"><a href="#使用有意义的且可读的变量名" class="headerlink" title="使用有意义的且可读的变量名"></a>使用有意义的且可读的变量名</h3><p><strong>不友好的：</strong></p><pre><code class="php">$ymdstr = $moment-&gt;format(&#39;y-m-d&#39;);</code></pre><p><strong>友好的：</strong></p><pre><code class="php">$currentDate = $moment-&gt;format(&#39;y-m-d&#39;);</code></pre><h3 id="对同类型的变量使用相同的词汇"><a href="#对同类型的变量使用相同的词汇" class="headerlink" title="对同类型的变量使用相同的词汇"></a>对同类型的变量使用相同的词汇</h3><p><strong>不友好的：</strong></p><pre><code class="php">getUserInfo();getUserData();getUserRecord();getUserProfile();</code></pre><p><strong>友好的：</strong></p><pre><code class="php">getUser();</code></pre><h3 id="使用可搜索的名称（第一部分）"><a href="#使用可搜索的名称（第一部分）" class="headerlink" title="使用可搜索的名称（第一部分）"></a>使用可搜索的名称（第一部分）</h3><p>我们阅读的代码超过我们写的代码。所以我们写出的代码需要具备可读性、可搜索性，这一点非常重要。要我们去理解程序中没有名字的变量是非常头疼的。让你的变量可搜索吧！</p><p><strong>不具备可读性的代码：</strong></p><pre><code class="php">//  见鬼的 448 是什么意思？$result = $serializer-&gt;serialize($data, 448);</code></pre><p><strong>具备可读性的：</strong></p><pre><code class="php">$json = $serializer-&gt;serialize($data, JSON_UNESCAPED_SLASHES | JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE);</code></pre><h3 id="使用可搜索的名称（第二部分）"><a href="#使用可搜索的名称（第二部分）" class="headerlink" title="使用可搜索的名称（第二部分）"></a>使用可搜索的名称（第二部分）</h3><p><strong>不好的：</strong></p><pre><code class="php">// 见鬼的 4 又是什么意思？if ($user-&gt;access &amp; 4) {    // ...}</code></pre><p><strong>好的方式：</strong></p><pre><code class="php">class User{    const ACCESS_READ = 1;    const ACCESS_CREATE = 2;    const ACCESS_UPDATE = 4;    const ACCESS_DELETE = 8;}if ($user-&gt;access &amp; User::ACCESS_UPDATE) {    // do edit ...}</code></pre><h3 id="使用解释性变量"><a href="#使用解释性变量" class="headerlink" title="使用解释性变量"></a>使用解释性变量</h3><p><strong>不好：</strong></p><pre><code class="php">$address = &#39;One Infinite Loop, Cupertino 95014&#39;;$cityZipCodeRegex = &#39;/^[^,]+,\s*(.+?)\s*(\d{5})$/&#39;;preg_match($cityZipCodeRegex, $address, $matches);saveCityZipCode($matches[1], $matches[2]);</code></pre><p><strong>一般：</strong></p><p>这个好点，但我们仍严重依赖正则表达式。</p><pre><code class="php">$address = &#39;One Infinite Loop, Cupertino 95014&#39;;$cityZipCodeRegex = &#39;/^[^,]+,\s*(.+?)\s*(\d{5})$/&#39;;preg_match($cityZipCodeRegex, $address, $matches);[, $city, $zipCode] = $matches;saveCityZipCode($city, $zipCode);</code></pre><p><strong>很棒：</strong></p><p>通过命名子模式减少对正则表达式的依赖。</p><pre><code class="php">$address = &#39;One Infinite Loop, Cupertino 95014&#39;;$cityZipCodeRegex = &#39;/^[^,]+,\s*(?&lt;city&gt;.+?)\s*(?&lt;zipCode&gt;\d{5})$/&#39;;preg_match($cityZipCodeRegex, $address, $matches);saveCityZipCode($matches[&#39;city&#39;], $matches[&#39;zipCode&#39;]);</code></pre><h3 id="避免嵌套太深和提前返回-第一部分"><a href="#避免嵌套太深和提前返回-第一部分" class="headerlink" title="避免嵌套太深和提前返回 (第一部分)"></a>避免嵌套太深和提前返回 (第一部分)</h3><p>使用太多 <code>if else</code> 表达式会导致代码难以理解。<br>明确优于隐式。</p><p><strong>不好:</strong></p><pre><code class="php">function isShopOpen($day): bool{    if ($day) {        if (is_string($day)) {            $day = strtolower($day);            if ($day === &#39;friday&#39;) {                return true;            } elseif ($day === &#39;saturday&#39;) {                return true;            } elseif ($day === &#39;sunday&#39;) {                return true;            } else {                return false;            }        } else {            return false;        }    } else {        return false;    }}</code></pre><p><strong>很棒：</strong></p><pre><code class="php">function isShopOpen(string $day): bool{    if (empty($day)) {        return false;    }    $openingDays = [        &#39;friday&#39;, &#39;saturday&#39;, &#39;sunday&#39;    ];    return in_array(strtolower($day), $openingDays, true);}</code></pre><h3 id="避免嵌套太深和提前返回-第二部分"><a href="#避免嵌套太深和提前返回-第二部分" class="headerlink" title="避免嵌套太深和提前返回 (第二部分)"></a>避免嵌套太深和提前返回 (第二部分)</h3><p><strong>不好：</strong></p><pre><code class="php">function fibonacci(int $n){    if ($n &lt; 50) {        if ($n !== 0) {            if ($n !== 1) {                return fibonacci($n - 1) + fibonacci($n - 2);            } else {                return 1;            }        } else {            return 0;        }    } else {        return &#39;Not supported&#39;;    }}</code></pre><p><strong>很棒：</strong></p><pre><code class="php">function fibonacci(int $n): int{    if ($n === 0 || $n === 1) {        return $n;    }    if ($n &gt; 50) {        throw new \Exception(&#39;Not supported&#39;);    }    return fibonacci($n - 1) + fibonacci($n - 2);}</code></pre><h3 id="避免心理映射"><a href="#避免心理映射" class="headerlink" title="避免心理映射"></a>避免心理映射</h3><p>不要迫使你的代码阅读者翻译变量的意义。<br>明确优于隐式。</p><p><strong>不好：</strong></p><pre><code class="php">$l = [&#39;Austin&#39;, &#39;New York&#39;, &#39;San Francisco&#39;];for ($i = 0; $i &lt; count($l); $i++) {    $li = $l[$i];    doStuff();    doSomeOtherStuff();    // ...    // ...    // ...    // Wait, what is `$li` for again?    dispatch($li);}</code></pre><p><strong>很棒：</strong></p><pre><code class="php">$locations = [&#39;Austin&#39;, &#39;New York&#39;, &#39;San Francisco&#39;];foreach ($locations as $location) {    doStuff();    doSomeOtherStuff();    // ...    // ...    // ...    dispatch($location);}</code></pre><h3 id="不要增加不需要的上下文"><a href="#不要增加不需要的上下文" class="headerlink" title="不要增加不需要的上下文"></a>不要增加不需要的上下文</h3><p>如果类名或对象名告诉你某些东西后，请不要在变量名中重复。</p><p><strong>小坏坏：</strong></p><pre><code class="php">class Car{    public $carMake;    public $carModel;    public $carColor;    //...}</code></pre><p><strong>好的方式：</strong></p><pre><code class="php">class Car{    public $make;    public $model;    public $color;    //...}</code></pre><h3 id="使用默认参数而不是使用短路运算或者是条件判断"><a href="#使用默认参数而不是使用短路运算或者是条件判断" class="headerlink" title="使用默认参数而不是使用短路运算或者是条件判断"></a>使用默认参数而不是使用短路运算或者是条件判断</h3><p><strong>不好的做法:</strong></p><p>这是不太好的因为 <code>$breweryName</code> 可以是 <code>NULL</code>.</p><pre><code class="php">function createMicrobrewery($breweryName = &#39;Hipster Brew Co.&#39;): void{    // ...}</code></pre><p><strong>还算可以的做法:</strong></p><p>这个做法比上面的更加容易理解，但是它需要很好的去控制变量的值.</p><pre><code class="php">function createMicrobrewery($name = null): void{    $breweryName = $name ?: &#39;Hipster Brew Co.&#39;;    // ...}</code></pre><p><strong>好的做法:</strong></p><p>你可以使用 <a href="http://php.net/manual/en/functions.arguments.php#functions.arguments.type-declaration" target="_blank" rel="noopener">类型提示</a> 而且可以保证 <code>$breweryName</code> 不会为空 <code>NULL</code>.</p><pre><code class="php">function createMicrobrewery(string $breweryName = &#39;Hipster Brew Co.&#39;): void{    // ...}</code></pre><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><h3 id="使用-相等运算符"><a href="#使用-相等运算符" class="headerlink" title="使用 相等运算符"></a>使用 <a href="http://php.net/manual/en/language.operators.comparison.php" target="_blank" rel="noopener">相等运算符</a></h3><p><strong>不好的做法:</strong></p><pre><code class="php">$a = &#39;42&#39;;$b = 42;使用简单的相等运算符会把字符串类型转换成数字类型if( $a != $b ) {   //这个条件表达式总是会通过}</code></pre><p>表达式 $a != $b 会返回 false 但实际上它应该是 true !<br>字符串类型 ‘42’ 是不同于数字类型的 42</p><p><strong>好的做法:</strong><br>使用全等运算符会对比类型和值</p><pre><code class="php">if( $a !== $b ) {    //这个条件是通过的}</code></pre><p>表达式 $a !== $b 会返回 true。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数参数（2-个或更少）"><a href="#函数参数（2-个或更少）" class="headerlink" title="函数参数（2 个或更少）"></a>函数参数（2 个或更少）</h3><p>限制函数参数个数极其重要<br>这样测试你的函数容易点。有超过 3 个可选参数会导致一个爆炸式组合增长，你会有成吨独立参数情形要测试。</p><p>无参数是理想情况。1 个或 2 个都可以，最好避免 3 个。<br>再多就需要加固了。通常如果你的函数有超过两个参数，说明他要处理的事太多了。 如果必须要传入很多数据，建议封装一个高级别对象作为参数。</p><p><strong>不友好的:</strong></p><pre><code class="php">function createMenu(string $title, string $body, string $buttonText, bool $cancellable): void{    // ...}</code></pre><p><strong>友好的:</strong></p><pre><code class="php">class MenuConfig{    public $title;    public $body;    public $buttonText;    public $cancellable = false;}$config = new MenuConfig();$config-&gt;title = &#39;Foo&#39;;$config-&gt;body = &#39;Bar&#39;;$config-&gt;buttonText = &#39;Baz&#39;;$config-&gt;cancellable = true;function createMenu(MenuConfig $config): void{    // ...}</code></pre><h3 id="函数应该只做一件事情"><a href="#函数应该只做一件事情" class="headerlink" title="函数应该只做一件事情"></a>函数应该只做一件事情</h3><p>这是迄今为止软件工程最重要的原则。函数做了超过一件事情时，它们将变得难以编写、测试、推导。 而函数只做一件事情时，重构起来则非常简单，同时代码阅读起来也非常清晰。掌握了这个原则，你就会领先许多其他的开发者。</p><p><strong>不好的:</strong></p><pre><code class="php">function emailClients(array $clients): void{    foreach ($clients as $client) {        $clientRecord = $db-&gt;find($client);        if ($clientRecord-&gt;isActive()) {            email($client);        }    }}</code></pre><p><strong>好的:</strong></p><pre><code class="php">function emailClients(array $clients): void{    $activeClients = activeClients($clients);    array_walk($activeClients, &#39;email&#39;);}function activeClients(array $clients): array{    return array_filter($clients, &#39;isClientActive&#39;);}function isClientActive(int $client): bool{    $clientRecord = $db-&gt;find($client);    return $clientRecord-&gt;isActive();}</code></pre><h3 id="函数的名称要说清楚它做什么"><a href="#函数的名称要说清楚它做什么" class="headerlink" title="函数的名称要说清楚它做什么"></a>函数的名称要说清楚它做什么</h3><p><strong>不好的例子:</strong></p><pre><code class="php">class Email{    //...    public function handle(): void    {        mail($this-&gt;to, $this-&gt;subject, $this-&gt;body);    }}$message = new Email(...);// What is this? A handle for the message? Are we writing to a file now?$message-&gt;handle();</code></pre><p><strong>很好的例子:</strong></p><pre><code class="php">class Email {    //...    public function send(): void    {        mail($this-&gt;to, $this-&gt;subject, $this-&gt;body);    }}$message = new Email(...);// Clear and obvious$message-&gt;send();</code></pre><h3 id="函数只能是一个抽象级别"><a href="#函数只能是一个抽象级别" class="headerlink" title="函数只能是一个抽象级别"></a>函数只能是一个抽象级别</h3><p>当你有多个抽象层次时，你的函数功能通常是做太多了。 分割函数功能使得重用性和测试更加容易。.</p><p><strong>不好:</strong></p><pre><code class="php">function parseBetterJSAlternative(string $code): void{    $regexes = [        // ...    ];    $statements = explode(&#39; &#39;, $code);    $tokens = [];    foreach ($regexes as $regex) {        foreach ($statements as $statement) {            // ...        }    }    $ast = [];    foreach ($tokens as $token) {        // lex...    }    foreach ($ast as $node) {        // parse...    }}</code></pre><p><strong>同样不是很好:</strong></p><p>我们已经完成了一些功能，但是 <code>parseBetterJSAlternative()</code> 功能仍然非常复杂，测试起来也比较麻烦。</p><pre><code class="php">function tokenize(string $code): array{    $regexes = [        // ...    ];    $statements = explode(&#39; &#39;, $code);    $tokens = [];    foreach ($regexes as $regex) {        foreach ($statements as $statement) {            $tokens[] = /* ... */;        }    }    return $tokens;}function lexer(array $tokens): array{    $ast = [];    foreach ($tokens as $token) {        $ast[] = /* ... */;    }    return $ast;}function parseBetterJSAlternative(string $code): void{    $tokens = tokenize($code);    $ast = lexer($tokens);    foreach ($ast as $node) {        // parse...    }}</code></pre><p><strong>很好的:</strong></p><p>最好的解决方案是取出 <code>parseBetterJSAlternative()</code> 函数的依赖关系.</p><pre><code class="php">class Tokenizer{    public function tokenize(string $code): array    {        $regexes = [            // ...        ];        $statements = explode(&#39; &#39;, $code);        $tokens = [];        foreach ($regexes as $regex) {            foreach ($statements as $statement) {                $tokens[] = /* ... */;            }        }        return $tokens;    }}class Lexer{    public function lexify(array $tokens): array    {        $ast = [];        foreach ($tokens as $token) {            $ast[] = /* ... */;        }        return $ast;    }}class BetterJSAlternative{    private $tokenizer;    private $lexer;    public function __construct(Tokenizer $tokenizer, Lexer $lexer)    {        $this-&gt;tokenizer = $tokenizer;        $this-&gt;lexer = $lexer;    }    public function parse(string $code): void    {        $tokens = $this-&gt;tokenizer-&gt;tokenize($code);        $ast = $this-&gt;lexer-&gt;lexify($tokens);        foreach ($ast as $node) {            // parse...        }    }}</code></pre><h3 id="不要用标示作为函数的参数"><a href="#不要用标示作为函数的参数" class="headerlink" title="不要用标示作为函数的参数"></a>不要用标示作为函数的参数</h3><p>标示就是在告诉大家，这个方法里处理很多事。前面刚说过，一个函数应当只做一件事。 把不同标示的代码拆分到多个函数里。</p><p><strong>不友好的:</strong></p><pre><code class="php">function createFile(string $name, bool $temp = false): void{    if ($temp) {        touch(&#39;./temp/&#39;.$name);    } else {        touch($name);    }}</code></pre><p><strong>友好的:</strong></p><pre><code class="php">function createFile(string $name): void{    touch($name);}function createTempFile(string $name): void{    touch(&#39;./temp/&#39;.$name);}</code></pre><h3 id="避免副作用"><a href="#避免副作用" class="headerlink" title="避免副作用"></a>避免副作用</h3><p>一个函数应该只获取数值，然后返回另外的数值，如果在这个过程中还做了其他的事情，我们就称为副作用。副作用可能是写入一个文件，修改某些全局变量，或者意外的把你全部的钱给了陌生人。</p><p>现在，你的确需要在一个程序或者场合里要有副作用，像之前的例子，你也许需要写一个文件。你需要做的是把你做这些的地方集中起来。不要用几个函数和类来写入一个特定的文件。只允许使用一个服务来单独实现。</p><p>重点是避免常见陷阱比如对象间共享无结构的数据、使用可以写入任何的可变数据类型、不集中去处理这些副作用。如果你做了这些你就会比大多数程序员快乐。</p><p><strong>不好的:</strong></p><pre><code class="php">// 这个全局变量在函数中被使用// 如果我们在别的方法中使用这个全局变量，有可能我们会不小心将其修改为数组类型$name = &#39;Ryan McDermott&#39;;function splitIntoFirstAndLastName(): void{    global $name;    $name = explode(&#39; &#39;, $name);}splitIntoFirstAndLastName();var_dump($name); // [&#39;Ryan&#39;, &#39;McDermott&#39;];</code></pre><p><strong>推荐的:</strong></p><pre><code class="php">function splitIntoFirstAndLastName(string $name): array{    return explode(&#39; &#39;, $name);}$name = &#39;Ryan McDermott&#39;;$newName = splitIntoFirstAndLastName($name);var_dump($name); // &#39;Ryan McDermott&#39;;var_dump($newName); // [&#39;Ryan&#39;, &#39;McDermott&#39;];</code></pre><h3 id="不要定义全局函数"><a href="#不要定义全局函数" class="headerlink" title="不要定义全局函数"></a>不要定义全局函数</h3><p>在很多语言中定义全局函数是一个坏习惯，因为你定义的全局函数可能与其他人的函数库冲突，并且，除非在实际运用中遇到异常，否则你的 API 的使用者将无法觉察到这一点。接下来我们来看看一个例子：当你想有一个配置数组，你可能会写一个 <code>config()</code> 的全局函数，但是这样会与其他人定义的库冲突。</p><p><strong>不好的:</strong></p><pre><code class="php">function config(): array{    return  [        &#39;foo&#39; =&gt; &#39;bar&#39;,    ]}</code></pre><p><strong>好的:</strong></p><pre><code class="php">class Configuration{    private $configuration = [];    public function __construct(array $configuration)    {        $this-&gt;configuration = $configuration;    }    public function get(string $key): ?string    {        return isset($this-&gt;configuration[$key]) ? $this-&gt;configuration[$key] : null;    }}</code></pre><p>获取配置需要先创建 <code>Configuration</code> 类的实例，如下：</p><pre><code class="php">$configuration = new Configuration([    &#39;foo&#39; =&gt; &#39;bar&#39;,]);</code></pre><p>现在，在你的应用中必须使用 <code>Configuration</code> 的实例了。</p><h3 id="不要使用单例模式"><a href="#不要使用单例模式" class="headerlink" title="不要使用单例模式"></a>不要使用单例模式</h3><p>单例模式是个 <a href="https://en.wikipedia.org/wiki/Singleton_pattern" target="_blank" rel="noopener">反模式</a>。 以下转述 Brian Button 的观点：</p><ol><li>单例模式常用于 <strong>全局实例</strong>， 这么做为什么不好呢？ 因为在你的代码里 <strong>你隐藏了应用的依赖关系</strong>，而没有通过接口公开依赖关系 。避免全局的东西扩散使用是一种 <a href="https://en.wikipedia.org/wiki/Code_smell" target="_blank" rel="noopener">代码味道</a>.</li><li>单例模式违反了 <a href="https://learnku.com/laravel/t/7774/the-conciseness-of-the-php-code-php-clean-code#single-responsibility-principle-srp" target="_blank" rel="noopener">单一责任原则</a>： 依据的事实就是 <strong>单例模式自己控制自身的创建和生命周期</strong>.</li><li>单例模式天生就导致代码紧 <a href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)" target="_blank" rel="noopener">耦合</a>。这使得在许多情况下用伪造的数据 <strong>难于测试</strong>。</li><li>单例模式的状态会留存于应用的整个生命周期。 这会对测试产生第二次打击，<strong>你只能让被严令需要测试的代码运行不了</strong>收场，根本不能进行单元测试。为何？因为每一个单元测试应该彼此独立。</li></ol><p>还有些来自 <a href="http://misko.hevery.com/about/" target="_blank" rel="noopener">Misko Hevery</a> 的深入思考，关于单例模式的 <a href="http://misko.hevery.com/2008/08/25/root-cause-of-singletons/" target="_blank" rel="noopener">问题根源</a>。</p><p><strong>不好的示范：</strong></p><pre><code class="php">class DBConnection{    private static $instance;    private function __construct(string $dsn)    {        // ...    }    public static function getInstance(): DBConnection    {        if (self::$instance === null) {            self::$instance = new self();        }        return self::$instance;    }    // ...}$singleton = DBConnection::getInstance();</code></pre><p><strong>好的示范：</strong></p><pre><code class="php">class DBConnection{    public function __construct(string $dsn)    {        // ...    }     // ...}</code></pre><p>用 <a href="http://php.net/manual/en/pdo.construct.php#refsect1-pdo.construct-parameters" target="_blank" rel="noopener">DSN</a> 进行配置创建的 <code>DBConnection</code> 类实例。</p><pre><code class="php">$connection = new DBConnection($dsn);</code></pre><p>现在就必须在你的应用中使用 <code>DBConnection</code> 的实例了。</p><h3 id="封装条件语句"><a href="#封装条件语句" class="headerlink" title="封装条件语句"></a>封装条件语句</h3><p><strong>不友好的:</strong></p><pre><code class="php">if ($article-&gt;state === &#39;published&#39;) {    // ...}</code></pre><p><strong>友好的:</strong></p><pre><code class="php">if ($article-&gt;isPublished()) {    // ...}</code></pre><h3 id="避免用反义条件判断"><a href="#避免用反义条件判断" class="headerlink" title="避免用反义条件判断"></a>避免用反义条件判断</h3><p><strong>不友好的:</strong></p><pre><code class="php">function isDOMNodeNotPresent(\DOMNode $node): bool{    // ...}if (!isDOMNodeNotPresent($node)){    // ...}</code></pre><p><strong>友好的:</strong></p><pre><code class="php">function isDOMNodePresent(\DOMNode $node): bool{    // ...}if (isDOMNodePresent($node)) {    // ...}</code></pre><h3 id="避免使用条件语句"><a href="#避免使用条件语句" class="headerlink" title="避免使用条件语句"></a>避免使用条件语句</h3><p>这听起来像是个不可能实现的任务。 当第一次听到这个时，大部分人都会说，“没有 <code>if</code> 语句，我该怎么办？” 答案就是在很多情况下你可以使用多态性来实现同样的任务。 接着第二个问题来了， “听着不错，但我为什么需要那样做？”，这个答案就是我们之前所学的干净代码概念：一个函数应该只做一件事情。如果你的类或函数有 <code>if</code> 语句，这就告诉了使用者你的类或函数干了不止一件事情。 记住，只要做一件事情。</p><p><strong>不好的:</strong></p><pre><code class="php">class Airplane{    // ...    public function getCruisingAltitude(): int    {        switch ($this-&gt;type) {            case &#39;777&#39;:                return $this-&gt;getMaxAltitude() - $this-&gt;getPassengerCount();            case &#39;Air Force One&#39;:                return $this-&gt;getMaxAltitude();            case &#39;Cessna&#39;:                return $this-&gt;getMaxAltitude() - $this-&gt;getFuelExpenditure();        }    }}</code></pre><p><strong>好的:</strong></p><pre><code class="php">interface Airplane{    // ...    public function getCruisingAltitude(): int;}class Boeing777 implements Airplane{    // ...    public function getCruisingAltitude(): int    {        return $this-&gt;getMaxAltitude() - $this-&gt;getPassengerCount();    }}class AirForceOne implements Airplane{    // ...    public function getCruisingAltitude(): int    {        return $this-&gt;getMaxAltitude();    }}class Cessna implements Airplane{    // ...    public function getCruisingAltitude(): int    {        return $this-&gt;getMaxAltitude() - $this-&gt;getFuelExpenditure();    }}</code></pre><h3 id="避免类型检测-第-1-部分"><a href="#避免类型检测-第-1-部分" class="headerlink" title="避免类型检测 (第 1 部分)"></a>避免类型检测 (第 1 部分)</h3><p>PHP 是无类型的，这意味着你的函数可以接受任何类型的参数。<br>有时这种自由会让你感到困扰，并且他会让你自然而然的在函数中使用类型检测。有很多方法可以避免这么做。<br>首先考虑 API 的一致性。</p><p><strong>不好的：</strong></p><pre><code class="php">function travelToTexas($vehicle): void{    if ($vehicle instanceof Bicycle) {        $vehicle-&gt;pedalTo(new Location(&#39;texas&#39;));    } elseif ($vehicle instanceof Car) {        $vehicle-&gt;driveTo(new Location(&#39;texas&#39;));    }}</code></pre><p><strong>好的：</strong></p><pre><code class="php">function travelToTexas(Traveler $vehicle): void{    $vehicle-&gt;travelTo(new Location(&#39;texas&#39;));}</code></pre><h3 id="避免类型检查（第-2-部分）"><a href="#避免类型检查（第-2-部分）" class="headerlink" title="避免类型检查（第 2 部分）"></a>避免类型检查（第 2 部分）</h3><p>如果你正在使用像 字符串、数值、或数组这样的基础类型，你使用的是 PHP 版本是 PHP 7+，并且你不能使用多态，但仍然觉得需要使用类型检测，这时，你应该考虑 <a href="http://php.net/manual/en/functions.arguments.php#functions.arguments.type-declaration" target="_blank" rel="noopener">类型定义</a> 或 严格模式。它为您提供了标准 PHP 语法之上的静态类型。<br>手动进行类型检查的问题是做这件事需要这么多的额外言辞，你所得到的虚假的『类型安全』并不能弥补丢失的可读性。保持你的代码简洁，编写良好的测试，并且拥有好的代码审查。<br>否则，使用 PHP 严格的类型声明或严格模式完成所有这些工作。</p><p><strong>不好的：</strong></p><pre><code class="php">function combine($val1, $val2): int{    if (!is_numeric($val1) || !is_numeric($val2)) {        throw new \Exception(&#39;Must be of type Number&#39;);    }    return $val1 + $val2;}</code></pre><p><strong>好的：</strong></p><pre><code class="php">function combine(int $val1, int $val2): int{    return $val1 + $val2;}</code></pre><h3 id="移除无用代码"><a href="#移除无用代码" class="headerlink" title="移除无用代码"></a>移除无用代码</h3><p>无用代码和重复代码一样糟糕。 如果没有被调用，就应该把它删除掉，没必要将它保留在你的代码库中！当你需要它的时候，可以在你的历史版本中找到它。</p><p><strong>Bad:</strong></p><pre><code class="php">function oldRequestModule(string $url): void{    // ...}function newRequestModule(string $url): void{    // ...}$request = newRequestModule($requestUrl);inventoryTracker(&#39;apples&#39;, $request, &#39;www.inventory-awesome.io&#39;);</code></pre><p><strong>Good:</strong></p><pre><code class="php">function requestModule(string $url): void{    // ...}$request = requestModule($requestUrl);inventoryTracker(&#39;apples&#39;, $request, &#39;www.inventory-awesome.io&#39;);</code></pre><h2 id="对象和数据结构"><a href="#对象和数据结构" class="headerlink" title="对象和数据结构"></a>对象和数据结构</h2><h3 id="使用对象封装"><a href="#使用对象封装" class="headerlink" title="使用对象封装"></a>使用对象封装</h3><p>在 PHP 中，你可以在方法中使用关键字，如 <code>public</code>, <code>protected</code> and <code>private</code>。<br>使用它们，你可以任意的控制、修改对象的属性。</p><ul><li>当你除获取对象属性外还想做更多的操作时，你不需要修改你的代码</li><li>当 <code>set</code> 属性时，易于增加参数验证。</li><li>封装的内部表示。</li><li>容易在获取和设置属性时添加日志和错误处理。</li><li>继承这个类，你可以重写默认信息。</li><li>你可以延迟加载对象的属性，比如从服务器获取数据。</li></ul><p>此外，这样的方式也符合 OOP 开发中的 [开闭原则](# 开闭原则 (OCP))</p><p><strong>不好的:</strong></p><pre><code class="php">class BankAccount{    public $balance = 1000;}$bankAccount = new BankAccount();// Buy shoes...$bankAccount-&gt;balance -= 100;</code></pre><p><strong>好的:</strong></p><pre><code class="php">class BankAccount{    private $balance;    public function __construct(int $balance = 1000)    {      $this-&gt;balance = $balance;    }    public function withdraw(int $amount): void    {        if ($amount &gt; $this-&gt;balance) {            throw new \Exception(&#39;Amount greater than available balance.&#39;);        }        $this-&gt;balance -= $amount;    }    public function deposit(int $amount): void    {        $this-&gt;balance += $amount;    }    public function getBalance(): int    {        return $this-&gt;balance;    }}$bankAccount = new BankAccount();// Buy shoes...$bankAccount-&gt;withdraw($shoesPrice);// Get balance$balance = $bankAccount-&gt;getBalance();</code></pre><h3 id="让对象拥有-private-protected-属性的成员"><a href="#让对象拥有-private-protected-属性的成员" class="headerlink" title="让对象拥有 private/protected 属性的成员"></a>让对象拥有 private/protected 属性的成员</h3><ul><li><code>public</code> 公有方法和属性对于变化来说是最危险的，因为一些外部的代码可能会轻易的依赖他们，但是你没法控制那些依赖他们的代码。 <strong>类的变化对于类的所有使用者来说都是危险的。</strong></li><li><code>protected</code> 受保护的属性变化和 public 公有的同样危险，因为他们在子类范围内是可用的。也就是说 public 和 protected 之间的区别仅仅在于访问机制，只有封装才能保证属性是一致的。<strong>任何在类内的变化对于所有继承子类来说都是危险的 。</strong></li><li><code>private</code> 私有属性的变化可以保证代码 <strong>只对单个类范围内的危险</strong> (对于修改你是安全的，并且你不会有其他类似堆积木的影响 <a href="http://www.urbandictionary.com/define.php?term=Jengaphobia&defid=2494196" target="_blank" rel="noopener">Jenga effect</a>).</li></ul><p>因此，请默认使用 <code>private</code> 属性，只有当需要对外部类提供访问属性的时候才采用 <code>public/protected</code> 属性。</p><p>更多的信息可以参考 <a href="https://github.com/fabpot" target="_blank" rel="noopener">Fabien Potencier</a> 写的针对这个专栏的文章 <a href="http://fabien.potencier.org/pragmatism-over-theory-protected-vs-private.html" target="_blank" rel="noopener">blog post</a> .</p><p><strong>Bad:</strong></p><pre><code class="php">class Employee{    public $name;    public function __construct(string $name)    {        $this-&gt;name = $name;    }}$employee = new Employee(&#39;John Doe&#39;);echo &#39;Employee name: &#39;.$employee-&gt;name; // Employee name: John Doe</code></pre><p><strong>Good:</strong></p><pre><code class="php">class Employee{    private $name;    public function __construct(string $name)    {        $this-&gt;name = $name;    }    public function getName(): string    {        return $this-&gt;name;    }}$employee = new Employee(&#39;John Doe&#39;);echo &#39;Employee name: &#39;.$employee-&gt;getName(); // Employee name: John Doe</code></pre><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="组合优于继承"><a href="#组合优于继承" class="headerlink" title="组合优于继承"></a>组合优于继承</h3><p>正如 the Gang of Four 所著的 <a href="https://en.wikipedia.org/wiki/Design_Patterns" target="_blank" rel="noopener"><em>设计模式</em></a> 中所说，<br>我们应该尽量优先选择组合而不是继承的方式。使用继承和组合都有很多好处。<br>这个准则的主要意义在于当你本能的使用继承时，试着思考一下<strong>组合</strong>是否能更好对你的需求建模。<br>在一些情况下，是这样的。</p><p>接下来你或许会想，“那我应该在什么时候使用继承？”<br>答案依赖于你的问题，当然下面有一些何时继承比组合更好的说明：</p><ol><li>你的继承表达了 “是一个” 而不是 “有一个” 的关系（例如人类 “是” 动物，而用户 “有” 用户详情）。</li><li>你可以复用基类的代码（人类可以像动物一样移动）。</li><li>你想通过修改基类对所有派生类做全局的修改（当动物移动时，修改它们的能量消耗）。</li></ol><p><strong>糟糕的:</strong></p><pre><code class="php">class Employee {    private $name;    private $email;    public function __construct(string $name, string $email)    {        $this-&gt;name = $name;        $this-&gt;email = $email;    }    // ...}// 不好，因为Employees &quot;有&quot; taxdata// 而EmployeeTaxData不是Employee类型的class EmployeeTaxData extends Employee {    private $ssn;    private $salary;    public function __construct(string $name, string $email, string $ssn, string $salary)    {        parent::__construct($name, $email);        $this-&gt;ssn = $ssn;        $this-&gt;salary = $salary;    }    // ...}</code></pre><p><strong>棒棒哒:</strong></p><pre><code class="php">class EmployeeTaxData {    private $ssn;    private $salary;    public function __construct(string $ssn, string $salary)    {        $this-&gt;ssn = $ssn;        $this-&gt;salary = $salary;    }    // ...}class Employee {    private $name;    private $email;    private $taxData;    public function __construct(string $name, string $email)    {        $this-&gt;name = $name;        $this-&gt;email = $email;    }    public function setTaxData(string $ssn, string $salary)    {        $this-&gt;taxData = new EmployeeTaxData($ssn, $salary);    }    // ...}</code></pre><h3 id="避免流式接口"><a href="#避免流式接口" class="headerlink" title="避免流式接口"></a>避免流式接口</h3><p><a href="https://en.wikipedia.org/wiki/Fluent_interface" target="_blank" rel="noopener">流式接口</a> 是一种面向对象 API 的方法，旨在通过方法链 <a href="https://en.wikipedia.org/wiki/Method_chaining" target="_blank" rel="noopener">Method chaining</a> 来提高源代码的可阅读性.</p><p>流式接口虽然需要一些上下文，需要经常构建对象，但是这种模式减少了代码的冗余度 (例如： <a href="https://phpunit.de/manual/current/en/test-doubles.html" target="_blank" rel="noopener">PHPUnit Mock Builder</a><br>或 <a href="http://docs.doctrine-project.org/projects/doctrine-dbal/en/latest/reference/query-builder.html" target="_blank" rel="noopener">Doctrine Query Builder</a>)</p><p>但是同样它也带来了很多麻烦:</p><ol><li>破坏了封装 <a href="https://en.wikipedia.org/wiki/Encapsulation_(object-oriented_programming)" target="_blank" rel="noopener">Encapsulation</a></li><li>破坏了原型 <a href="https://en.wikipedia.org/wiki/Decorator_pattern" target="_blank" rel="noopener">Decorators</a></li><li>难以模拟测试 <a href="https://en.wikipedia.org/wiki/Mock_object" target="_blank" rel="noopener">mock</a></li><li>使得多次提交的代码难以理解</li></ol><p>更多信息可以参考 <a href="https://github.com/Ocramius" target="_blank" rel="noopener">Marco Pivetta</a> 撰写的关于这个专题的文章 <a href="https://ocramius.github.io/blog/fluent-interfaces-are-evil/" target="_blank" rel="noopener">blog post</a></p><p><strong>Bad:</strong></p><pre><code class="php">class Car{    private $make = &#39;Honda&#39;;    private $model = &#39;Accord&#39;;    private $color = &#39;white&#39;;    public function setMake(string $make): self    {        $this-&gt;make = $make;        // NOTE: Returning this for chaining        return $this;    }    public function setModel(string $model): self    {        $this-&gt;model = $model;        // NOTE: Returning this for chaining        return $this;    }    public function setColor(string $color): self    {        $this-&gt;color = $color;        // NOTE: Returning this for chaining        return $this;    }    public function dump(): void    {        var_dump($this-&gt;make, $this-&gt;model, $this-&gt;color);    }}$car = (new Car())  -&gt;setColor(&#39;pink&#39;)  -&gt;setMake(&#39;Ford&#39;)  -&gt;setModel(&#39;F-150&#39;)  -&gt;dump();</code></pre><p><strong>Good:</strong></p><pre><code class="php">class Car{    private $make = &#39;Honda&#39;;    private $model = &#39;Accord&#39;;    private $color = &#39;white&#39;;    public function setMake(string $make): void    {        $this-&gt;make = $make;    }    public function setModel(string $model): void    {        $this-&gt;model = $model;    }    public function setColor(string $color): void    {        $this-&gt;color = $color;    }    public function dump(): void    {        var_dump($this-&gt;make, $this-&gt;model, $this-&gt;color);    }}$car = new Car();$car-&gt;setColor(&#39;pink&#39;);$car-&gt;setMake(&#39;Ford&#39;);$car-&gt;setModel(&#39;F-150&#39;);$car-&gt;dump();</code></pre><h2 id="SOLID"><a href="#SOLID" class="headerlink" title="SOLID"></a>SOLID</h2><p><strong>SOLID</strong> 是 Michael Feathers 推荐的便于记忆的首字母简写，它代表了 Robert Martin 命名的最重要的五个面向对象编程设计原则：</p><ul><li><a href="https://learnku.com/laravel/t/7774/the-conciseness-of-the-php-code-php-clean-code#single-responsibility-principle-srp" target="_blank" rel="noopener">S: 职责单一原则 (SRP)</a></li><li><a href="https://learnku.com/laravel/t/7774/the-conciseness-of-the-php-code-php-clean-code#openclosed-principle-ocp" target="_blank" rel="noopener">O: 开闭原则 (OCP)</a></li><li><a href="https://learnku.com/laravel/t/7774/the-conciseness-of-the-php-code-php-clean-code#liskov-substitution-principle-lsp" target="_blank" rel="noopener">L: 里氏替换原则 (LSP)</a></li><li><a href="https://learnku.com/laravel/t/7774/the-conciseness-of-the-php-code-php-clean-code#interface-segregation-principle-isp" target="_blank" rel="noopener">I: 接口隔离原则 (ISP)</a></li><li><a href="https://learnku.com/laravel/t/7774/the-conciseness-of-the-php-code-php-clean-code#dependency-inversion-principle-dip" target="_blank" rel="noopener">D: 依赖反转原则 (DIP)</a></li></ul><h3 id="职责单一原则-Single-Responsibility-Principle-SRP"><a href="#职责单一原则-Single-Responsibility-Principle-SRP" class="headerlink" title="职责单一原则 Single Responsibility Principle (SRP)"></a>职责单一原则 Single Responsibility Principle (SRP)</h3><p>正如 <em>Clean Code</em> 书中所述，”修改一个类应该只为一个理由”。人们总是容易去用一堆方法 “塞满” 一个类，就好像当我们坐飞机上只能携带一个行李箱时，会把所有的东西都塞到这个箱子里。这样做带来的后果是：从逻辑上讲，这样的类不是高内聚的，并且留下了很多以后去修改它的理由。<br>将你需要修改类的次数降低到最小很重要，这是因为，当类中有很多方法时，修改某一处，你很难知晓在整个代码库中有哪些依赖于此的模块会被影响。</p><p><strong>比较糟:</strong></p><pre><code class="php">class UserSettings{    private $user;    public function __construct(User $user)    {        $this-&gt;user = $user;    }    public function changeSettings(array $settings): void    {        if ($this-&gt;verifyCredentials()) {            // ...        }    }    private function verifyCredentials(): bool    {        // ...    }}</code></pre><p><strong>棒棒哒:</strong></p><pre><code class="php">class UserAuth {    private $user;    public function __construct(User $user)    {        $this-&gt;user = $user;    }    public function verifyCredentials(): bool    {        // ...    }}class UserSettings {    private $user;    private $auth;    public function __construct(User $user)     {        $this-&gt;user = $user;        $this-&gt;auth = new UserAuth($user);    }    public function changeSettings(array $settings): void    {        if ($this-&gt;auth-&gt;verifyCredentials()) {            // ...        }    }}</code></pre><h3 id="开闭原则-OCP"><a href="#开闭原则-OCP" class="headerlink" title="开闭原则 (OCP)"></a>开闭原则 (OCP)</h3><p>如 Bertrand Meyer 所述，”软件实体 (类，模块，功能，等) 应该对扩展开放，但对修改关闭.” 这意味着什么？这个原则大体上是指你应该允许用户在不修改已有代码情况下添加功能.</p><p><strong>坏的:</strong></p><pre><code class="php">abstract class Adapter{    protected $name;    public function getName(): string    {        return $this-&gt;name;    }}class AjaxAdapter extends Adapter{    public function __construct()    {        parent::__construct();        $this-&gt;name = &#39;ajaxAdapter&#39;;    }}class NodeAdapter extends Adapter{    public function __construct()    {        parent::__construct();        $this-&gt;name = &#39;nodeAdapter&#39;;    }}class HttpRequester{    private $adapter;    public function __construct(Adapter $adapter)    {        $this-&gt;adapter = $adapter;    }    public function fetch(string $url): Promise    {        $adapterName = $this-&gt;adapter-&gt;getName();        if ($adapterName === &#39;ajaxAdapter&#39;) {            return $this-&gt;makeAjaxCall($url);        } elseif ($adapterName === &#39;httpNodeAdapter&#39;) {            return $this-&gt;makeHttpCall($url);        }    }    private function makeAjaxCall(string $url): Promise    {        // request and return promise    }    private function makeHttpCall(string $url): Promise    {        // request and return promise    }}</code></pre><p><strong>好的:</strong></p><pre><code class="php">interface Adapter{    public function request(string $url): Promise;}class AjaxAdapter implements Adapter{    public function request(string $url): Promise    {        // request and return promise    }}class NodeAdapter implements Adapter{    public function request(string $url): Promise    {        // request and return promise    }}class HttpRequester{    private $adapter;    public function __construct(Adapter $adapter)    {        $this-&gt;adapter = $adapter;    }    public function fetch(string $url): Promise    {        return $this-&gt;adapter-&gt;request($url);    }}</code></pre><h3 id="里氏代换原则-LSP"><a href="#里氏代换原则-LSP" class="headerlink" title="里氏代换原则 (LSP)"></a>里氏代换原则 (LSP)</h3><p>这是一个简单概念的可怕术语。它通常被定义为 “如果 S 是 T 的一个子类型，则 T 型对象可以替换为 S 型对象”<br>(i.e., S 类型的对象可以替换 T 型对象) 在不改变程序的任何理想属性的情况下 (正确性，任务完成度，etc.).” 这是一个更可怕的定义.<br>这个的最佳解释是，如果你有个父类和一个子类，然后父类和子类可以互换使用而不会得到不正确的结果。这或许依然令人疑惑，所以我们来看下经典的正方形 - 矩形例子。几何定义，正方形是矩形，但是，如果你通过继承建立了 “IS-a” 关系的模型，你很快就会陷入麻烦。.</p><p><strong>不好的:</strong></p><pre><code class="php">class Rectangle{    protected $width = 0;    protected $height = 0;    public function render(int $area): void    {        // ...    }    public function setWidth(int $width): void    {        $this-&gt;width = $width;    }    public function setHeight(int $height): void    {        $this-&gt;height = $height;    }    public function getArea(): int    {        return $this-&gt;width * $this-&gt;height;    }}class Square extends Rectangle{    public function setWidth(int $width): void    {        $this-&gt;width = $this-&gt;height = $width;    }    public function setHeight(int $height): void    {        $this-&gt;width = $this-&gt;height = $height;    }}/** * @param Rectangle[] $rectangles */function renderLargeRectangles(array $rectangles): void{    foreach ($rectangles as $rectangle) {        $rectangle-&gt;setWidth(4);        $rectangle-&gt;setHeight(5);        $area = $rectangle-&gt;getArea(); // BAD: Will return 25 for Square. Should be 20.        $rectangle-&gt;render($area);    }}$rectangles = [new Rectangle(), new Rectangle(), new Square()];renderLargeRectangles($rectangles);</code></pre><p><strong>优秀的:</strong></p><pre><code class="php">abstract class Shape{    abstract public function getArea(): int;    public function render(int $area): void    {        // ...    }}class Rectangle extends Shape{    private $width;    private $height;    public function __construct(int $width, int $height)    {        $this-&gt;width = $width;        $this-&gt;height = $height;    }    public function getArea(): int    {        return $this-&gt;width * $this-&gt;height;    }}class Square extends Shape{    private $length;    public function __construct(int $length)    {        $this-&gt;length = $length;    }    public function getArea(): int    {        return pow($this-&gt;length, 2);    }}/** * @param Rectangle[] $rectangles */function renderLargeRectangles(array $rectangles): void{    foreach ($rectangles as $rectangle) {        $area = $rectangle-&gt;getArea();         $rectangle-&gt;render($area);    }}$shapes = [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];renderLargeRectangles($shapes);</code></pre><h3 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则 (ISP)"></a>接口隔离原则 (ISP)</h3><p>ISP 指出 “客户不应该被强制依赖于他们用不到的接口.”</p><p>一个好的例子来观察证实此原则的是针对需要大量设置对象的类，不要求客户端设置大量的选项是有益的，因为多数情况下他们不需要所有的设置。使他们可选来避免产生一个 “臃肿的接口”.</p><p><strong>坏的:</strong></p><pre><code class="php">interface Employee{    public function work(): void;    public function eat(): void;}class Human implements Employee{    public function work(): void    {        // ....working    }    public function eat(): void    {        // ...... eating in lunch break    }}class Robot implements Employee{    public function work(): void    {        //.... working much more    }    public function eat(): void    {        //.... robot can&#39;t eat, but it must implement this method    }}</code></pre><p><strong>好的:</strong></p><p>并不是每个工人都是雇员，但每个雇员都是工人.</p><pre><code class="php">interface Workable{    public function work(): void;}interface Feedable{    public function eat(): void;}interface Employee extends Feedable, Workable{}class Human implements Employee{    public function work(): void    {        // ....working    }    public function eat(): void    {        //.... eating in lunch break    }}// robot can only workclass Robot implements Workable{    public function work(): void    {        // ....working    }}</code></pre><h3 id="依赖反转原则-DIP"><a href="#依赖反转原则-DIP" class="headerlink" title="依赖反转原则 (DIP)"></a>依赖反转原则 (DIP)</h3><p>这一原则规定了两项基本内容:</p><ol><li>高级模块不应依赖于低级模块。两者都应该依赖于抽象.</li><li>抽象类不应依赖于实例。实例应该依赖于抽象.</li></ol><p>一开始可能很难去理解，但是你如果工作中使用过 php 框架（如 Symfony）, 你应该见过以依赖的形式执行这一原则<br>依赖注入 (DI). 虽然他们不是相同的概念，DIP 可以让高级模块不需要了解其低级模块的详细信息而安装它们.<br>通过依赖注入可以做到。这样做的一个巨大好处是减少了模块之间的耦合。耦合是一种非常糟糕的开发模式，因为它使您的代码难以重构.</p><p><strong>不好的:</strong></p><pre><code class="php">class Employee{    public function work(): void    {        // ....working    }}class Robot extends Employee{    public function work(): void    {        //.... working much more    }}class Manager{    private $employee;    public function __construct(Employee $employee)    {        $this-&gt;employee = $employee;    }    public function manage(): void    {        $this-&gt;employee-&gt;work();    }}</code></pre><p><strong>优秀的:</strong></p><pre><code class="php">interface Employee{    public function work(): void;}class Human implements Employee{    public function work(): void    {        // ....working    }}class Robot implements Employee{    public function work(): void    {        //.... working much more    }}class Manager{    private $employee;    public function __construct(Employee $employee)    {        $this-&gt;employee = $employee;    }    public function manage(): void    {        $this-&gt;employee-&gt;work();    }}</code></pre><h2 id="别写重复代码-DRY"><a href="#别写重复代码-DRY" class="headerlink" title="别写重复代码 (DRY)"></a>别写重复代码 (DRY)</h2><p>试着去遵循 <a href="https://en.wikipedia.org/wiki/Don' target="_blank" rel="noopener"t_repeat_yourself">DRY</a> 原则。</p><p>尽你最大的努力去避免复制代码，它是一种非常糟糕的行为，复制代码通常意味着当你需要变更一些逻辑时，你需要修改不止一处。</p><p>试想一下，如果你在经营一家餐厅，并且你需要记录你仓库的进销记录：包括所有的土豆，洋葱，大蒜，辣椒，等等。如果你使用多个表格来管理进销记录，当你用其中一些土豆做菜时，你需要更新所有的表格。如果你只有一个列表的话就只需要更新一个地方。</p><p>通常情况下你复制代码的原因可能是它们大多数都是一样的，只不过有两个或者多个略微不同的逻辑，但是由于这些区别，最终导致你写出了两个或者多个隔离的但大部分相同的方法，移除重复的代码意味着用一个 function/module/class 创建一个能处理差异的抽象。</p><p>正确的抽象是非常关键的，这正是为什么你必须学习遵守在 <a href="https://learnku.com/laravel/t/7774/the-conciseness-of-the-php-code-php-clean-code#classes" target="_blank" rel="noopener">Classes</a> 章节展开讨论的的 <strong>SOLID</strong> 原则，不合理的抽象比复制代码更糟糕，所以请务必谨慎！说了这么多，如果你能设计一个合理的抽象，就去实现它！最后再说一遍，不要写重复代码，否则你会发现当你想修改一个逻辑时，你必须去修改多个地方！</p><p><strong>糟糕的:</strong></p><pre><code class="php">function showDeveloperList(array $developers): void{    foreach ($developers as $developer) {        $expectedSalary = $developer-&gt;calculateExpectedSalary();        $experience = $developer-&gt;getExperience();        $githubLink = $developer-&gt;getGithubLink();        $data = [            $expectedSalary,            $experience,            $githubLink        ];        render($data);    }}function showManagerList(array $managers): void{    foreach ($managers as $manager) {        $expectedSalary = $manager-&gt;calculateExpectedSalary();        $experience = $manager-&gt;getExperience();        $githubLink = $manager-&gt;getGithubLink();        $data = [            $expectedSalary,            $experience,            $githubLink        ];        render($data);    }}</code></pre><p><strong>好的:</strong></p><pre><code class="php">function showList(array $employees): void{    foreach ($employees as $employee) {        $expectedSalary = $employee-&gt;calculateExpectedSalary();        $experience = $employee-&gt;getExperience();        $githubLink = $employee-&gt;getGithubLink();        $data = [            $expectedSalary,            $experience,            $githubLink        ];        render($data);    }}</code></pre><p><strong>非常好:</strong></p><p>最好让你的代码紧凑一点。</p><pre><code class="php">function showList(array $employees): void{    foreach ($employees as $employee) {        render([            $employee-&gt;calculateExpectedSalary(),            $employee-&gt;getExperience(),            $employee-&gt;getGithubLink()        ]);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;PHP-代码简洁之道&quot;&gt;&lt;a href=&quot;#PHP-代码简洁之道&quot; class=&quot;headerlink&quot; title=&quot;PHP 代码简洁之道&quot;&gt;&lt;/a&gt;PHP 代码简洁之道&lt;/h2&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://ljheisenberg1072.github.io/categories/PHP/"/>
    
    
      <category term="Clean" scheme="https://ljheisenberg1072.github.io/tags/Clean/"/>
    
  </entry>
  
  <entry>
    <title>手动部署 Laravel 应用</title>
    <link href="https://ljheisenberg1072.github.io/2019/11/20/deploy-laravel-project-byhands/"/>
    <id>https://ljheisenberg1072.github.io/2019/11/20/deploy-laravel-project-byhands/</id>
    <published>2019-11-20T04:30:44.000Z</published>
    <updated>2019-11-20T07:40:33.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="手动部署-Laravel-应用（基于Ubuntu18-04）"><a href="#手动部署-Laravel-应用（基于Ubuntu18-04）" class="headerlink" title="手动部署 Laravel 应用（基于Ubuntu18.04）"></a>手动部署 Laravel 应用（基于Ubuntu18.04）</h2><h3 id="0-腾讯云服务器需要注意"><a href="#0-腾讯云服务器需要注意" class="headerlink" title="0. 腾讯云服务器需要注意"></a>0. 腾讯云服务器需要注意</h3><ol><li>禁用<code>systemd-resolved</code>服务</li></ol><pre><code class="bash">$ systemctl stop systemd-resolved$ systemctl disable systemd-resolved</code></pre><ol start="2"><li>编辑<code>/etc/resolv.conf</code>文件，默认是<code>127.0.0.53</code></li></ol><pre><code class="bash">$ nameserver 127.0.0.53            # 原始$ nameserver 114.114.114.114    # 替换后</code></pre><ol start="3"><li>注意<code>/etc/apt/source.list</code>中的源地址<br>把<code>mirrors.tencentyun.com</code>替换成<code>mirrors.cloud.tencent.com</code>，否则镜像有问题</li></ol><h3 id="1-初始化系统"><a href="#1-初始化系统" class="headerlink" title="1. 初始化系统"></a>1. 初始化系统</h3><ol><li>更新软件源</li></ol><pre><code class="bash">$ apt update</code></pre><ol start="2"><li>查看可升级软件包，并升级（生产环境谨慎操作）</li></ol><pre><code class="bash">$ apt list --upgradable$ apt upgrade</code></pre><ol start="3"><li>本地化配置（国内服务器都已经配置好）</li></ol><pre><code class="bash">$ locale-gen en_US.UTF-8$ update-locale LC_ALL=en_US.UTF-8$ timedatectl set-timezone Asia/Shanghai</code></pre><h3 id="2-安装-Nginx"><a href="#2-安装-Nginx" class="headerlink" title="2. 安装 Nginx"></a>2. 安装 Nginx</h3><ol><li>安装 Nginx</li></ol><pre><code class="bash">$ apt install nginx</code></pre><ol start="2"><li>管理 Nginx 服务</li></ol><pre><code class="bash">$ service nginx start        # 启动 Nginx$ service nginx stop        # 停止 Nginx$ service nginx restart        # 重启 Nginx$ systemctl enable nginx    # 启用 Nginx 开机启动$ systemctl disable nginx     # 禁用 Nginx 开机启动</code></pre><ol start="3"><li>确认 Nginx 正常运行</li></ol><p>在浏览器内输入服务器公网 IP（或域名）并打开，出现欢迎界面说明 Nginx 安装成功</p><h3 id="3-安装-PHP-FPM"><a href="#3-安装-PHP-FPM" class="headerlink" title="3. 安装 PHP-FPM"></a>3. 安装 PHP-FPM</h3><ol><li>配置第三方软件源</li></ol><pre><code class="bash">$ apt install -y software-properties-common$ add-apt-repository -y ppa:ondrej/php$ apt-get update</code></pre><ol start="2"><li>安装 PHP</li></ol><p>PHP 的安装分为三个软件包：PHP、PHP-CLI、PHP-FPM</p><pre><code class="bash">$ apt install -y php7.2 php7.2-cli php7.2-fpm</code></pre><ol start="3"><li>安装 PHP 必要的扩展</li></ol><pre><code class="bash">$ apt install -y php7.2-mbstring php7.2-xml php7.2-bcmath php7.2-curl php7.2-gd php7.2-mysql php7.2-opcache php7.2-zip php7.2-sqlite3 php7.2-json</code></pre><ol start="4"><li>根据命令搜索当前软件源内包</li></ol><pre><code class="bash">$ apt-cache search php7.2</code></pre><ol start="5"><li>管理 PHP-FPM 服务</li></ol><pre><code class="bash">$ service php7.2-fpm restart    # 重启 PHP-FPM$ service php7.2-fpm start        # 启动 PHP-FPM$ service php7.2-fpm stop        # 停止 PHP-FPM$ systemctl enable php7.2-fpm    # 启用 PHP-FPM 开机启动$ systemctl disable php7.2-fpm    # 禁用 PHP-FPM 开机启动</code></pre><ol start="6"><li>确认 PHP-FPM 正常运行</li></ol><pre><code class="bash">$ ps aux | grep php</code></pre><p>如果 PHP-FPM 进程不存在，则只有 <code>grep</code> 进程</p><h3 id="4-安装-Git-和-Composer"><a href="#4-安装-Git-和-Composer" class="headerlink" title="4. 安装 Git 和 Composer"></a>4. 安装 Git 和 Composer</h3><ol><li>安装 Git</li></ol><pre><code class="bash">$ apt install -y git</code></pre><ol start="2"><li>安装 Composer</li></ol><pre><code class="bash">$ wget https://raw.githubusercontent.com/composer/getcomposer.org/master/web/installer -O - -q | php -- --filename=composer -- install-dir=/usr/local/bin</code></pre><ol start="3"><li>composer 执行权限问题（新建普通用户，防止composer包有恶意代码）</li></ol><pre><code class="bash">$ composer -VDo not run Composer as root/super user!</code></pre><ol start="4"><li>配置 Packagist 中国镜像</li></ol><pre><code class="bash">$ composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/</code></pre><h3 id="5-安全加固，避免使用根目录用户"><a href="#5-安全加固，避免使用根目录用户" class="headerlink" title="5. 安全加固，避免使用根目录用户"></a>5. 安全加固，避免使用根目录用户</h3><ol><li>创建新用户</li></ol><p>在创建新用户前先创建用户组，例如<code>foodaily</code></p><pre><code class="bash">$ addgroup foodailycompany</code></pre><p>随后创建新用户，例如<code>foodaily</code></p><pre><code class="bash">$ useradd -d /home/foodaily -s /bin/bash -m foodaily</code></pre><p>接着将用户添加至用户组：</p><pre><code class="bash">$ usermod -a -G foodailycompany -G www-data foodaily</code></pre><p>最后为新用户设置密码：</p><pre><code class="bash">$ passwd foodaily$ Enter new UNIX password:&lt;输入密码&gt;$ Retype new UNIX password:&lt;再次输入密码&gt;</code></pre><p>切换到新用户下面</p><pre><code class="bash">$ su foodaily</code></pre><p>切换回 root 用户</p><pre><code class="bash">$ su root</code></pre><ol start="2"><li>测试效果</li></ol><p>断开 SSH 链接，在本地使用以下命令作为<code>foodaily</code>用户登录到服务器</p><pre><code class="bash">$ ssh foodaily@公网IP$ foodaily@公网IP&#39;s password:&lt;输入密码&gt;</code></pre><ol start="3"><li>禁止根用户 SSH 登录</li></ol><pre><code class="bash">$ sed -i -E &#39;s/#?\s*(PermitRootLogin)(.*)$/\1 no/&#39; /etc/ssh/sshd_config</code></pre><p>建议手动编辑 <code>/etc/ssh/sshd_config</code> 文件，搜索<code>PermitRootLogin</code>这一关键字，将整行改成<code>PermitRootLogin no</code>，确保正行修改，首尾无多余字符<br>随后重启 SSH 服务即可</p><pre><code class="bash">$ service ssh restart</code></pre><ol start="4"><li>再次测试效果</li></ol><pre><code class="bash">$ ssh root@公网IP$ Permission denied, please try again.</code></pre><p><strong>注意</strong> ：如果要使用<code>root</code>用户，需要先通过<code>foodaily</code>用户 SSH 登录服务器，然后再通过<code>su root</code> 来切换 root 用户</p><h3 id="6-部署应用代码"><a href="#6-部署应用代码" class="headerlink" title="6. 部署应用代码"></a>6. 部署应用代码</h3><ol><li>使用 Git 拉取项目（HTTPS 协议）</li></ol><pre><code class="bash">$ cd /var/www/$ git clone https://github.com/username/demo.git demo$ Username for &#39;https://github.com&#39;: &lt;输入你的用户名&gt;$ Password for &#39;https://example@github.com&#39;: &lt;请输入你的密码&gt;</code></pre><p>私有项目需要输入账号和密码</p><ol start="2"><li>使用 Composer 安装依赖</li></ol><pre><code class="bash">$ cd demo$ composer install</code></pre><p>提示找不到<code>unzip</code>扩展</p><pre><code class="bash">$ apt install unzip</code></pre><ol start="3"><li>使用 Npm 或者 Yarn 安装依赖</li></ol><pre><code class="bash">$ cd demo$ sudo npm/yarn install</code></pre><ol start="4"><li>配置环境变量</li></ol><p>依赖安装完成后，需要将<code>.env.example</code>文件复制为<code>.env</code>文件，并生成<code>APP_KEY</code>秘钥：</p><pre><code class="bash">$ cd /var/www/demo$ php -r &quot;file_exists(&#39;.env&#39;) || copy(&#39;.env.example&#39;, &#39;.env&#39;);&quot;$ php artisan key:generate --ansi</code></pre><ol start="5"><li>配置文件所有者</li></ol><pre><code class="bash">$ chown -R www-data:www-data .</code></pre><h3 id="7-配置-Nginx-站点"><a href="#7-配置-Nginx-站点" class="headerlink" title="7. 配置 Nginx 站点"></a>7. 配置 Nginx 站点</h3><ol><li>在<code>/etc/nginx/sites-enabled</code>文件夹下放置每个网站的conf</li></ol><pre><code class="bash">$ foodaily.conf</code></pre><ol start="2"><li>现成 Nginx 配置如下：</li></ol><pre><code class="php">server {    listen 80;    server_name 公网IP或域名;     # 此为必修改项，请替换为服务器公网 IP 或域名    root /var/www/demo/public; # 此为必修改项，请注意指向站点根目录的 public 子目录    add_header X-Frame-Options &quot;SAMEORIGIN&quot;;    add_header X-XSS-Protection &quot;1; mode=block&quot;;    add_header X-Content-Type-Options &quot;nosniff&quot;;    index index.html index.htm index.php;    charset utf-8;    location / {        try_files $uri $uri/ /index.php?$query_string;    }    location = /favicon.ico { access_log off; log_not_found off; }    location = /robots.txt  { access_log off; log_not_found off; }    error_page 404 /index.php;    location ~ \.php$ {        fastcgi_pass unix:/var/run/php/php7.2-fpm.sock; # 请注意核对 PHP 版本        fastcgi_index index.php;        fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;        include fastcgi_params;    }    location ~ /\.(?!well-known).* {        deny all;    }}</code></pre><p>通常仅需要修改 <code>server_name</code>、<code>root</code>和<code>fastcgi_pass</code>三个选项即可</p><ol start="3"><li>重载 Nginx（三者等价）</li></ol><pre><code class="bash">$ service nginx restart$ service nginx reload$ nginx -s reload</code></pre><ol start="4"><li>Nginx https配置</li></ol><pre><code class="php">server {    listen 443 ssl;    ssl_certificate /usr/local/nginx/ssl/server.crt;    ssl_certificate_key    /usr/local/nginx/ssl/server.key;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers HIGH:!aNULL:!MD5:!DH;    server_name 公网IP或域名;     # 此为必修改项，请替换为服务器公网 IP 或域名    server_name foodaily.com www.foodaily.com;    # 如果有www的要填写两个    root /var/www/demo/public; # 此为必修改项，请注意指向站点根目录的 public 子目录    add_header X-Frame-Options &quot;SAMEORIGIN&quot;;    add_header X-XSS-Protection &quot;1; mode=block&quot;;    add_header X-Content-Type-Options &quot;nosniff&quot;;    index index.html index.htm index.php;    charset utf-8;    location / {        try_files $uri $uri/ /index.php?$query_string;    }    location = /favicon.ico { access_log off; log_not_found off; }    location = /robots.txt  { access_log off; log_not_found off; }    error_page 404 /index.php;    location ~ \.php$ {        fastcgi_pass unix:/var/run/php/php7.2-fpm.sock; # 请注意核对 PHP 版本        fastcgi_index index.php;        fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;        include fastcgi_params;    }    location ~ /\.(?!well-known).* {        deny all;    }}# 全站使用 HTTPS，让通过 HTTP 访问的用户301跳转到 HTTPSserver {    listen    80;    server_name example.com www.example.com;    return 301 https://$server_name$request_uri;}</code></pre><h3 id="8-安装-MySQL-5-7"><a href="#8-安装-MySQL-5-7" class="headerlink" title="8. 安装 MySQL 5.7"></a>8. 安装 MySQL 5.7</h3><ol><li>安装 MySQL</li></ol><pre><code class="bash">$ sudo apt install mysql-server</code></pre><ol start="2"><li>配置 MySQL</li></ol><pre><code class="bash">$ sudo mysql_secure_installation</code></pre><p>在成功设置 root 密码后还有一些列的安全设置</p><ol start="3"><li>安全设置</li></ol><pre><code class="bash">$ Do you wish to continue with the password provided?([Y/n]): y$ Enter current password for root (enter for none): &lt;输入密码&gt;$ Change the root password? [Y/n] n$ Remove anonymous users? [Y/n] y$ Disallow root login remotely? [Y/n] n$ Remove test database and access to it? [Y/n] n$ Reload privilege tables now? [Y/n] y</code></pre><ol start="4"><li>添加用户</li></ol><pre><code class="bash">$ create user usernamexxx identified by &#39;passwordxxx&#39;;</code></pre><p>用户名：usernamexxx，密码：passwordxxx</p><ol start="5"><li>授权</li></ol><pre><code class="bash">$ grant all privileges on db_name.* to usernamexxx@&#39;%&#39; identified by &#39;passwordxxx&#39;;$ flush privileges;</code></pre><p>给用户<code>usernamexxx</code>赋予<code>db_name</code>数据库的所有表的所有权限</p><ol start="6"><li>修改密码</li></ol><pre><code class="bash">$ update mysql.user set password = password(&#39;passwordxxx&#39;) where user = &#39;usernamexxx&#39; and host = &#39;%&#39;;$ flush privileges;</code></pre><ol start="7"><li>删除用户（会删除用户以及对应的权限，mysql.user和mysql.db表的相应记录随之删除）</li></ol><pre><code class="bash">$ drop user usernamexxx@&#39;%&#39;;</code></pre><ol start="8"><li>使用MySQL</li></ol><pre><code class="bash">$ /etc/init.d/mysql start$ /etc/init.d/mysql stop$ /etc/init.d/mysql restart</code></pre><ol start="9"><li>MySQL密码含有特殊字符的话，在<code>.env</code>文件中要加上双引号，否则密码无法完全识别</li></ol><h3 id="9-生产环境的必要优化"><a href="#9-生产环境的必要优化" class="headerlink" title="9. 生产环境的必要优化"></a>9. 生产环境的必要优化</h3><ol><li>Nginx 配置</li></ol><pre><code class="php">server {    location ~* \.(js|css)$ {        expires 24h;    }}</code></pre><ol start="2"><li>Laravel 的配置缓存</li></ol><pre><code class="bash">$ php artisan config:cache        # 生成配置缓存</code></pre><p><strong>注意</strong> ：当开启配置缓存后，<code>env()</code>函数将会失效，它永远返回null，因此务必确保在非config目录下使用env函数。生成缓存后，对配置的修改将不会生效，需要执行下面命令清除它们</p><pre><code class="bash">$ php artisan config:clear        # 清除配置缓存</code></pre><ol start="3"><li>Laravel 的路由缓存</li></ol><pre><code class="bash">$ php artisan route:cache        # 生成路由缓存</code></pre><p><strong>注意</strong>：若路由注册存在闭包，则无法使用该功能，生成缓存后，对路由的修改将不会生效，需要执行下面命令清除它们</p><pre><code class="bash">$ php artisan route:clear        # 清除路由缓存</code></pre><p><strong>注意</strong>：别直接使用下面命令清除所有缓存，因为有可能会清除掉 Redis 缓存</p><pre><code class="bash">$ php artisan cache:clear</code></pre><ol start="3"><li>Composer （安装依赖时）</li></ol><pre><code class="bash">$ composer install --optimize-autoloader --no-dev</code></pre><p>其中<code>--optimize-autoloader</code>表示生成优化后的自动加载器，<code>--no-dev</code>表示不安装composer.json中<code>require-dev</code>声明的扩展包</p><ol start="4"><li>文件权限</li></ol><p>文件权限应当遵守『最小权限原则』，即权限越小越好。</p><pre><code class="bash">$ chmod -R 750 /var/www/demo</code></pre><ol start="5"><li>杂项</li></ol><pre><code class="bash">$ php artisan storage:link        # 软链接，storage/app/public 到 public 目录$ php artisan migrate            # 执行迁移$ php artisan db:seed            # 执行数据填充</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;手动部署-Laravel-应用（基于Ubuntu18-04）&quot;&gt;&lt;a href=&quot;#手动部署-Laravel-应用（基于Ubuntu18-04）&quot; class=&quot;headerlink&quot; title=&quot;手动部署 Laravel 应用（基于Ubuntu18.04）&quot;&gt;
      
    
    </summary>
    
    
      <category term="Laravel" scheme="https://ljheisenberg1072.github.io/categories/Laravel/"/>
    
    
      <category term="部署" scheme="https://ljheisenberg1072.github.io/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
</feed>
